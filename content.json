{"meta":{"title":"刘正的技术博客","subtitle":"胆小认生，不易相处","description":"擅长Android技能,深入研究移动端开发,此为博客一枚。","author":"moment","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Android窗口管理框架源码解析整理","slug":"Android窗口管理框架源码解析","date":"2018-09-10T07:11:23.014Z","updated":"2018-09-10T07:11:23.014Z","comments":true,"path":"2018/09/10/Android窗口管理框架源码解析/","link":"","permalink":"http://yoursite.com/2018/09/10/Android窗口管理框架源码解析/","excerpt":"","text":"原文地址 Android open source project analysis 感谢原作者guoxiaoxing及相关技术大佬的无私付出. 此篇文章在各位大佬的源码分析文章的基础上对自己的理解进行整理，各位可结合原文分析使用，如有不实之处欢迎指正. Android窗口管理框架 [x] Android显示框架：Android应用视图的载体View measure流程 ViewGroup在onMeasure()中会调用所有子View的measure让它们进行自我测量并在onMeasure中会计算出自己的尺寸然后保存 ViewGroup根据子View计算出的期望尺寸来计算出它们的实际尺寸和位置然后保存。同时，根据子View的尺寸和位置来计算出自己的尺寸然后保存. viewGroup onMeasure() -&gt; view measure() -&gt; view onMeasure() 日常开发中我们接触最多的不是MeasureSpec而是LayoutParams，在View测量的时候，LayoutParams会和父View的MeasureSpec相结合被换算成View的MeasureSpec，进而决定View的大小。 View的MeasureSpec计算源码如下所示，该方法用来获取子View的MeasureSpec，由参数我们就可以知道子View的MeasureSpec由父容器的spec，父容器中已占用的的空间大小padding，以及子View自身大小childDimension共同来决定的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public abstract class ViewGroup extends View implements ViewParent, ViewManager &#123; public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = 0; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; &#125; View事件分发 1234567ViewGroup dispatchTouchEvent --&gt; ViewGroup onInterceptTouchEvent --&gt; onInterceptTouchEvent is True--&gt; |True| block--&gt; |False| View dispatchTouchEvent --&gt; View onTouchEvent --&gt; View performClick Android窗口管理框架：Android应用视图的管理者Window window 抽象类，定义了窗口类型，窗口参数以及窗口模式。在定义的窗口回调中进行事件分发，Activity实现了Window.Callback接口，将Activity关联给Window，Window就可以将一些事件交由Activity处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public interface Callback &#123; //键盘事件分发 public boolean dispatchKeyEvent(KeyEvent event); //触摸事件分发 public boolean dispatchTouchEvent(MotionEvent event); //轨迹球事件分发 public boolean dispatchTrackballEvent(MotionEvent event); //可见性事件分发 public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event); //创建Panel View public View onCreatePanelView(int featureId); //创建menu public boolean onCreatePanelMenu(int featureId, Menu menu); //画板准备好时回调 public boolean onPreparePanel(int featureId, View view, Menu menu); //menu打开时回调 public boolean onMenuOpened(int featureId, Menu menu); //menu item被选择时回调 public boolean onMenuItemSelected(int featureId, MenuItem item); //Window Attributes发生变化时回调 public void onWindowAttributesChanged(WindowManager.LayoutParams attrs); //Content View发生变化时回调 public void onContentChanged(); //窗口焦点发生变化时回调 public void onWindowFocusChanged(boolean hasFocus); //Window被添加到WIndowManager时回调 public void onAttachedToWindow(); //Window被从WIndowManager中移除时回调 public void onDetachedFromWindow(); */ //画板关闭时回调 public void onPanelClosed(int featureId, Menu menu); //用户开始执行搜索操作时回调 public boolean onSearchRequested(); &#125; 窗口的唯一实现类为PhoneWindow,PhoneWindow里包含了以下内容： private DecorView mDecor：DecorView是Activity中的顶级View，它本质上是一个FrameLayout，一般说来它内部包含标题栏和内容栏（com.android.internal.R.id.content） ViewGroup mContentParent：窗口内容视图，它是mDecor本身或者是它的子View。 private ImageView mLeftIconView：左上角图标 private ImageView mRightIconView：右上角图标 private ProgressBar mCircularProgressBar：圆形loading条 private ProgressBar mHorizontalProgressBar：水平loading条 其他的一些和转场动画相关的Transition与listener在PhoneWindow的setContentView方法中判断是否存在DecorView，没有的化就创建DecorView并将创建好的DecorView赋值给mContentParent具体实现如下: 123456789101112131415161718192021222324252627282930313233public class PhoneWindow extends Window implements MenuBuilder.Callback &#123; @Override public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; //1. 如果没有DecorView则创建它，并将创建好的DecorView赋值给mContentParent installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; //2. 将Activity传入的布局文件生成View并添加到mContentParent中 mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; //3. 回调Window.Callback里的onContentChanged()方法，这个Callback也被Activity //所持有，因此它实际回调的是Activity里的onContentChanged()方法，通知Activity //视图已经发生改变。 cb.onContentChanged(); &#125; mContentParentExplicitlySet = true; &#125; &#125; [x] Android窗口管理框架：Android应用窗口的管理服务WindowManagerService wms内容较为复杂建议参考原文分析理解 [x] Android窗口管理框架：Android布局解析者LayoutInflater 获取XmlResourceParser Activity 调用LayoutInflater的inflate inflate中调用Resources的getLayout(resource)去获取对应的XmlResourceParser。 getLayout(resource)又去调用了Resources的loadXmlResourceParser()方法来完成XmlResourceParser的加载 解析View树 获取树的深度，执行深度优先遍历. 逐个进行元素解析。 解析添加ad:focusable=”true”的元素，并获取View焦点。 解析View的tag。 解析include标签，注意include标签不能作为根元素，而merge必须作为根元素。 根据元素名进行解析，生成View。 递归调用解析该View里的所有子View，也是深度优先遍历，rInflateChildren内部调用的也是rInflate()方法，只是传入了新的parent View。 将解析出来的View添加到它的父View中。 回调根容器的onFinishInflate()方法，这个方法我们应该很熟悉。 解析view标签 解析View标签createViewFromTag。 如果标签与主题相关，则需要将context与themeResId包裹成ContextThemeWrapper。 BlinkLayout是一种会闪烁的布局，被包裹的内容会一直闪烁，像QQ消息那样。 用户可以设置LayoutInflater的Factory来进行View的解析，但是默认情况下这些Factory都是为空的。 默认情况下没有Factory，而是通过onCreateView()方法对内置View进行解析，createView()方法进行自定义View的解析。这里有个小技巧，因为我们在使用自定义View的时候是需要在xml指定全路径的，例如：com.guoxiaoxing.CustomView，那么这里就有个.了，可以利用这一点判定是内置View还是自定义View。 Android窗口管理框架：Android列表控件RecyclerView Adapter将数据DataSet翻译成RecyclerView可以理解的ViewHolder，Recycler负责对这些ViewHolder进行管理,LayoutManager从Recycler获取这些ViewHolder，然后在RecyclerView里对它们进行布局，在布局的过程中还可以通过ItemDecoration、ItemAnimator为这些ViewHolder添加分隔条、转场动画等东西，让整个RecyclerView更加具有交互性。 Android组件管理框架 [x] Android组件管理框架：Android组件管理服务ActivityManagerService init进程 –&gt; Zygote进程 –&gt; SystemServer进程 –&gt;各种应用进程 [x] Android组件管理框架：Android视图容器Activity 点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。 AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。 Zygote接收到新进程创建请求后fork出新进程。 在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。 ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。 什么情况下需要设置FLAG_ACTIVITY_NEW_TASK标志位 调用者不是Activity Context 调用者Activity调用single Instance 目标Activity设置的有single Instance或者single task 调用者处于finish状态 启动模式一共有四种 standard：多实例模式，每次启动都会有创建一个实例，默认会进入启动它的那个Activity所属的任务栈的栈顶，读者以前可能使用过Application Context去启动Activity，这是情况下会报错，就是因为 Application Context没有所谓的任务栈，解决的方式就是给它添加一个FLAG_ACTIVITY_NEW_TASK的标志位，创建一个新的任务栈。 singleTop：栈顶复用模式，如果新启动的Activity已经位于任务栈顶，则不会创建新的实例，而是回调原来Activity实例的onNewIntent()方法，如果新启动的Activity没有位于任务栈顶，则会创建 新的Activity实例。 singleTask：栈内复用模式，如果新启动的Activity已经位于任务栈内，则不会创建新的实例，而是回调原来Activity实例的onNewIntent()方法并且清除它之上的Activity（这里需要注意一下：任务栈里 的Activity是永远不会重排序的，所以它会清楚上方所有的Activity来让自己回到栈顶），如果新启动的Activity 没有位于任务栈，则新建一个Activity实例。 singleInstance：单实例模式，和singleTask相似，但是singleTask可以在多个栈里拥有多个实例，而singleInstance在多个栈里只能有唯一实例，这个一般用在特殊场景里，例如电话界面。","categories":[],"tags":[]},{"title":"Android SD卡下载路径切换","slug":"Android SD卡下载路径切换","date":"2018-03-22T07:07:25.000Z","updated":"2018-03-22T07:07:25.000Z","comments":true,"path":"2018/03/22/Android SD卡下载路径切换/","link":"","permalink":"http://yoursite.com/2018/03/22/Android SD卡下载路径切换/","excerpt":"","text":"存储机制原理及初始化Android存储机制 原文链接: Android | 图解外部存储和内部存储 内外部存储的区别 按照内外部存储：带External字眼则一定是外部存储的方法，如 getExternalFilesDir() ，外 部存储需要运行时权限； 按照公有私有性质：公有文件是Environment调用函数，而私有文件（包括内部私有与外部私有）是Context调用函数，公有文件不会随着app卸载而删除而私有则会，私有文件不会被Media Scanner扫描到。 需求描述 本人目前从事漫画类型APP开发，用户使用中低端机型（红米、oppo等）比例较高因此用户需要可以对下载路径进行修改因此有此次文章 先上效果图 Application初始化 初始化类：SdCardManager 12// packageName:应用applicationId 用来创建私有存储路径SdCardManager.getInstance().init(this, packageName) MainActivity初始化当前可用路径 12345678910111213141516171819/** * 初始化获取手机存储权限 * 默认存储路径为SD卡，当SD卡不存在或不可用时切换使用手机内存 */RxPermissions(this) .request(android.Manifest.permission.READ_EXTERNAL_STORAGE, android.Manifest.permission.WRITE_EXTERNAL_STORAGE) .subscribe(&#123; aBoolean -&gt; if (aBoolean) &#123; if (SdCardManager.getInstance().isDiskAvailable) &#123; if (SdCardManager.getInstance().isNullPath) &#123; SdCardManager.getInstance().changePath(SdCardManager.DownloadPath.SDCARD) &#125; &#125; else &#123; SdCardManager.getInstance().changePath(SdCardManager.DownloadPath.CACHE) &#125; &#125; else &#123; SdCardManager.getInstance().changePath(SdCardManager.DownloadPath.CACHE) &#125; &#125;, &#123; &#125;) 获取手机存储路径类相关代码,具体源码参考详见: Android文件存储位置切换 123456789101112131415161718/** * 获取存储设备及容量信息 */public static List&lt;MyStorageVolume&gt; getVolumeList(Context context) &#123; List&lt;MyStorageVolume&gt; svList = new ArrayList&lt;MyStorageVolume&gt;(3); StorageManager mStorageManager = (StorageManager) context .getSystemService(Activity.STORAGE_SERVICE); try &#123; Method mMethodGetPaths = mStorageManager.getClass().getMethod(&quot;getVolumeList&quot;); Object[] list = (Object[]) mMethodGetPaths.invoke(mStorageManager); for (Object item : list) &#123; svList.add(new MyStorageVolume(context, item)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return svList;&#125; 创建本地存储路径及SD卡存储路径文件夹,相关理论参考文章: 彻底搞懂Android文件存储—内部存储，外部存储以及各种存储路径解惑 1234567891011121314151617181920212223242526272829public static void createDir(Application application) &#123; File[] files; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; files = application.getExternalFilesDirs(&quot;download&quot;); for (File file : files) &#123; if (!file.exists()) &#123; file.mkdirs(); &#125; &#125; &#125; File file = getExternalStorageDirectory(); if (!file.exists()) &#123; file.mkdirs(); &#125; File file1 = application.getExternalFilesDir(&quot;download&quot;); if (!file1.exists()) &#123; file1.mkdirs(); &#125; File sdcard = new File(SdCardManager.getInstance().getDiskDownloadDir()); if (!sdcard.exists()) &#123; sdcard.mkdirs(); &#125; File cache = new File(SdCardManager.getInstance().getCacheDownloadDir()); if (!cache.exists()) &#123; cache.mkdirs(); &#125; &#125; 路径切换 获取当前使用存储路径,通过SdCardManager类获取当前正在使用中的存储路径并显示 1234567891011private fun getDownloadPath() &#123; if (SdCardManager.getInstance().isDiskNow) &#123; val builder = StringBuilder(activity.getString(R.string.download_path_dialog_sdcard) + &quot;:&quot;) builder.append(SdCardManager.getInstance().diskDownloadDir + &quot;&quot;) tv_download.text = builder.toString() &#125; else &#123; val builder = StringBuilder(activity.getString(R.string.download_path_dialog_phone) + &quot;:&quot;) builder.append(SdCardManager.getInstance().cacheDownloadDir + &quot;&quot;) tv_download.text = builder.toString() &#125; &#125; 存储路径选择 1234567891011121314151617private fun showPathDialog() &#123; RxPermissions(activity) .request(android.Manifest.permission.READ_EXTERNAL_STORAGE, android.Manifest.permission.WRITE_EXTERNAL_STORAGE) .subscribe(&#123; aBoolean -&gt; if (aBoolean!!) &#123; val dialog = PathDialog(activity) dialog.setOnPathChangeLisenter &#123; getDownloadPath() dialog.dismiss() &#125; dialog.show() dialog.setCanceledOnTouchOutside(true) &#125; else &#123; Toast.makeText(activity, &quot;无此权限，无法打开此功能！&quot;, Toast.LENGTH_SHORT).show() &#125; &#125;) &#123; &#125; &#125; 存储路径选择就涉及到存储路径获取，及存储路径大小获取，相关操作均在dialog中完成初始化及相关操作，关键代码如下： 1234567891011121314151617181920212223242526// 判断SD卡是否可用 if (SdCardManager.getInstance().isDiskAvailable()) &#123; rl_sdcard.setVisibility(View.VISIBLE); String sdcard = SdCardManager.getInstance().getSdcardName(); String size = &quot;剩余&quot; + StorageVolumeUtil.getSizeStr(StorageVolumeUtil.getAvailableSize(sdcard)) + &quot;可用，共&quot; + StorageVolumeUtil.getSizeStr(StorageVolumeUtil.getTotalSize(sdcard)); tv_sdcard_size.setText(&quot;&quot; + size); &#125; else &#123; rl_sdcard.setVisibility(View.GONE); &#125; // 获取手机存储路径 String phone = SdCardManager.getInstance().getCacheName(); // 计算路径大小 String size = &quot;剩余&quot; + StorageVolumeUtil.getSizeStr(StorageVolumeUtil.getAvailableSize(phone)) + &quot;可用，共&quot; + StorageVolumeUtil.getSizeStr(StorageVolumeUtil.getTotalSize(phone)); tv_phone_size.setText(&quot;&quot; + size); if (SdCardManager.getInstance().isDiskNow()) &#123; rb_sdcard.setChecked(true); rb_phone.setChecked(false); &#125; else &#123; rb_sdcard.setChecked(false); rb_phone.setChecked(true); &#125; 源码地址: https://github.com/momentslz/Eyepetizer欢迎大家多多star鼓励作者产出更多文章~~~","categories":[],"tags":[]},{"title":"Android图片加载-Glide4.0框架封装","slug":"Android图片加载-Glide4.0框架封装","date":"2018-03-22T07:06:34.000Z","updated":"2018-03-22T07:06:34.000Z","comments":true,"path":"2018/03/22/Android图片加载-Glide4.0框架封装/","link":"","permalink":"http://yoursite.com/2018/03/22/Android图片加载-Glide4.0框架封装/","excerpt":"","text":"基于现有项目存在大量高清美图展示的模块，所以在使用并对比了Glide和fresco的加载效果及使用体验后定下来的，两个框架都非常优秀但其侧重点略有不同之所以会选择Glide是因为本人挺喜欢Glide的API风格，简单方便而且不会涉及到自定义view. Glide地址：https://bumptech.github.io/glide/ 本次侧重点会放在对应用的内存管理上来，当然对于图片的处理也是内存管理相当重要的一部分. 先上效果图 使用步骤Glide添加1234567compile(&apos;com.github.bumptech.glide:glide:4.6.1&apos;) &#123; exclude group: &quot;com.android.support&quot; &#125;// glide kotlin 的工具包kapt &apos;com.github.bumptech.glide:compiler:4.6.1&apos;compile &quot;com.github.bumptech.glide:okhttp3-integration:4.5.0&quot;compile &apos;com.github.bumptech.glide:annotations:4.6.1&apos; 封装图片加载类目前只提供了简单的封装，当然你也可以根据项目需求继续进行拓展 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Created by moment on 2018/2/6. */class ImageLoad &#123; open fun load(context: WeakReference&lt;Context&gt;, url: String?, image: ImageView?) &#123; if (image == null) return // 具体图片加载实现可以使用第三方框架加载，也可以自己实现， 这里提供Glide4.0的使用示例： var requestOptions = RequestOptions().centerCrop() .placeholder(R.drawable.default_banner) .error(R.drawable.default_banner) .transform(CenterCrop()) .format(DecodeFormat.PREFER_RGB_565) .priority(Priority.LOW) .dontAnimate() .diskCacheStrategy(DiskCacheStrategy.RESOURCE) Glide.with(context.get()!!.applicationContext) .load(url) .apply(requestOptions) .into(object : DrawableImageViewTarget(image) &#123; &#125;) &#125; open fun load(context: WeakReference&lt;Context&gt;, url: String?, image: ImageView?, transformation: BitmapTransformation) &#123; if (image == null) return // 具体图片加载逻辑 &#125; open fun load(holder: Int, context: WeakReference&lt;Context&gt;, url: String, image: ImageView?, width: Int, height: Int) &#123; if (image == null) return // 具体图片加载逻辑 &#125; open fun loadCircle(context: WeakReference&lt;Context&gt;, url: String?, image: ImageView?, width_height: Int) &#123; if (image == null) return // 具体图片加载逻辑 &#125; open fun loadRound(context: WeakReference&lt;Context&gt;, url: String, image: ImageView?, width: Int, height: Int, round: Int) &#123; if (image == null) return // 具体图片加载逻辑 &#125; open fun clearCache(context: WeakReference&lt;Context&gt;) &#123; // 强制清楚缓存，可以为内存缓存也可以为硬盘缓存 Glide使用示例： Glide.get(context.get()!!.applicationContext).clearMemory() System.gc() &#125;&#125; 使用说明12345678// 加载圆形头像ImageLoad().loadCircle(WeakReference(mContext), remark.user_info.portrait, viewHolder.civ_avatar,40)// 加载正常图片ImageLoad().load(WeakReference(mContext), news.image_1, holder.imageView, width, height)// 加载圆角图片ImageLoad().loadRound(WeakReference(mContext), briefCard[&quot;icon&quot;].toString(), holder.image, 5) 在列表加载图片时会使应用的内存上升，但Glide提供给我们一个API来减少在列表加载时会损耗不必要的内存的方法，以recyclerview 为例：Android SD卡下载路径切换.md1234567891011121314151617recyclerview.addOnScrollListener(object : RecyclerView.OnScrollListener() &#123; override fun onScrollStateChanged(recyclerView: RecyclerView?, newState: Int) &#123; super.onScrollStateChanged(recyclerView, newState) when (newState) &#123; 2 -&gt; &#123; // SCROLL_STATE_FLING Glide.with(activity.applicationContext).pauseRequests() &#125; 0 -&gt; &#123; // SCROLL_STATE_IDLE Glide.with(activity.applicationContext).resumeRequests() &#125; 1 -&gt; &#123; // SCROLL_STATE_TOUCH_SCROLL Glide.with(activity.applicationContext).resumeRequests() &#125; &#125; &#125; &#125;) 在列表滑动过程中我们可以调用pauseRequests方法来是图片暂停加载，当滑动结束后再调用resumeRequests来恢复加载.当然要想降低应用内存开销的话也可以调用ImageLoad().clearCache(WeakReference(this@MainActivity.applicationContext))来清空Glide的内存缓存 具体使用方法及使用细节详见仿开眼视频Android客户端 欢迎大家多多star.","categories":[],"tags":[]},{"title":"仿开眼视频Android客户端","slug":"Eyepetizer","date":"2018-02-24T10:32:06.000Z","updated":"2018-02-24T10:32:06.000Z","comments":true,"path":"2018/02/24/Eyepetizer/","link":"","permalink":"http://yoursite.com/2018/02/24/Eyepetizer/","excerpt":"","text":"仿开眼视频Android客户端，本项目主要用来练手Google-MVP已及kotlin,对于急切想熟悉kotlin的童鞋来说是一个不错的练手项目，由于公司任务比较紧急所以本项目目前处于功能完善中，相关技术文章还未整理发布，想参与本项目开发的童鞋可以先自己去熟悉项目并在issues留言，或在目前的基础上进行修改，后续会陆续相关文章会发布到个人主页，欢迎各位积极PR,相关文章发布地址如下： 简书掘金blog源码地址 截图说明 项目功能简介 数据来源 开眼视频官网 本项目功能参考的是开眼视频Version 3.0所有API均来自开眼视频，数据接口均属于非正常渠道获取，请勿用于商业用途，原公司拥有数据所有权，侵权删. 应用功能 开眼视频首页分类tab切换【已完成】 开眼视频社区内容展示【已完成】 开眼视频搜索页面【已完成】 开眼视频首页置顶分类排序【待开发】 视频详情页添加【待开发】 视频缓存【待开发】 观看记录【待开发】 知识点 Google MVP kotlin tabLayout glide使用封装 rxbus RecyclerViewSnap实现类似viewpager的切换方式 技术栈googleMvp SlidingTabLayout 仿写SlidingTabLayout文章地址 : https://www.jianshu.com/p/c283a2403190 rxandroid RxRelay RecyclerViewSnap SmartRefreshLayout 1注：技术栈中的相关框架后期会进行源码解析，在原有框架基础上进行功能拓展 Changelog123452018-02-24 图片加载优化 2018-02-14 第一版上线，实现开眼视频基本功能 Demo下载网页下载：下载地址 二维码下载：","categories":[],"tags":[]},{"title":"自定义TabLayout","slug":"kotlin眼视频客户端 - 自定义TabLayout","date":"2018-02-24T09:49:39.000Z","updated":"2018-02-24T09:49:39.000Z","comments":true,"path":"2018/02/24/kotlin眼视频客户端 - 自定义TabLayout/","link":"","permalink":"http://yoursite.com/2018/02/24/kotlin眼视频客户端 - 自定义TabLayout/","excerpt":"","text":"本文为kotlin仿开眼视频Android客户端的后续补充内容，本篇为大家介绍如何对TabLayout进行定制使用，基于项目需求，本篇主要对部分功能进行了定制，如：指示器距离文字的距离、文字选中加粗、文字选中变大等 本文部分代码参考：FlycoTabLayout 效果图 效果-1 效果-2 参数详解属性源码 123456789101112131415&lt;declare-styleable name=&quot;MyTabLayout&quot;&gt; &lt;attr name=&quot;textNormalSize&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;textSelectSize&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;textNormalColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;textSelectColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;underLineHeight&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;underlineColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;indicatorHeight&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;indicatorWidth&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;indicatorSpacing&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;isTextBold&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;tabPadding&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;indicatorColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;tabSpaceEqual&quot; format=&quot;boolean&quot; /&gt; &lt;/declare-styleable&gt; 属性参数详解 参数 用处 textNormalSize tab未被选中时字体大小 textSelectSize tab被选中时字体大小 textNormalColor tab未被选中时字体颜色 textSelectColor tab被选中时字体颜色 underLineHeight tablayout下面整个一条的线的高度 underlineColor tablayout下面整个一条的线的颜色 indicatorHeight 文字下方指示器的高度 indicatorWidth 文字下方指示器的宽度 indicatorSpacing 文字下方指示器距离上面文字的间距 indicatorColor 文字下方指示器的颜色 isTextBold 文字选中时是否加粗 tabPadding 文字左右间的间隙大小 tabSpaceEqual tab中的文字是否等分tablayout的宽度，参考效果-2 与viewpager合并使用12345678var mAdapter = MyPagerAdapter(fragmentManager)viewpager.adapter = mAdapter//tab列表val stringArray = mTitle.toArray(arrayOfNulls&lt;String&gt;(0))tab_layout.setViewPager(viewpager, stringArray as Array&lt;String&gt;)viewpager.offscreenPageLimit = 3viewpager.currentItem = 0viewpager.addOnPageChangeListener(this) 源码使用参考详见:https://github.com/momentslz/Eyepetizer源码文件下载地址:https://github.com/momentslz/Eyepetizer/blob/master/app/src/main/java/com/moment/eyepetizer/view/TabLayout.kt 或如代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392/** * Created by moment on 2018/2/22. * FlycoTabLayout 仿写，并提取部分功能原地址链接： * https://github.com/H07000223/FlycoTabLayout */open class TabLayout(context: Context, attrs: AttributeSet) : HorizontalScrollView(context, attrs), ViewPager.OnPageChangeListener &#123; private var mContext: Context? = null private var textNormalSize: Float = 0.toFloat() private var textSelectSize: Float = 0.toFloat() private var textNormalColor: Int = 0 private var textSelectColor: Int = 0 private var underlineHeight: Float = 0.toFloat() private var underlineColor: Int = 0 private var indicatorHeight: Float = 0.toFloat() private var indicatorWidth: Float = 0.toFloat() private var indicatorSpacing: Float = 0.toFloat() private var isTextBold: Boolean = false private var tabPadding: Float = 0.toFloat() private var indicatorColor: Int = 0 private var tabSpaceEqual: Boolean = false private var selectListener: OnTagSelectListener? = null private var mTabsContainer: LinearLayout? = null private var mCurrentTab = 0 private var mViewPager: ViewPager? = null var tabCount: Int = 0 private set private var mTitles: ArrayList&lt;String&gt;? = null private val mRectPaint = Paint(Paint.ANTI_ALIAS_FLAG) private val mIndicatorDrawable = GradientDrawable() /** * indicator */ private val mIndicatorMarginLeft = 0f private val mIndicatorMarginTop = 0f private val mIndicatorMarginRight = 0f /** * 用于绘制显示器 */ private val mIndicatorRect = Rect() private var mCurrentPositionOffset: Float = 0.toFloat() /** * 用于实现滚动居中 */ private val mTabRect = Rect() private var mLastScrollX: Int = 0 init &#123; initResource(context, attrs) &#125; private fun initResource(context: Context, attrs: AttributeSet) &#123; mContext = context val typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyTabLayout) textNormalSize = typedArray.getDimension(R.styleable.MyTabLayout_textNormalSize, sp2px(context, 14f).toFloat()) textSelectSize = typedArray.getDimension(R.styleable.MyTabLayout_textSelectSize, textNormalSize) textNormalColor = typedArray.getColor(R.styleable.MyTabLayout_textNormalColor, Color.GRAY) textSelectColor = typedArray.getColor(R.styleable.MyTabLayout_textSelectColor, Color.BLACK) underlineHeight = typedArray.getDimension(R.styleable.MyTabLayout_underLineHeight, dp2px(context, 0.5f).toFloat()) indicatorWidth = typedArray.getDimension(R.styleable.MyTabLayout_indicatorWidth, -1f) indicatorHeight = typedArray.getDimension(R.styleable.MyTabLayout_indicatorHeight, dp2px(context, 3f).toFloat()) indicatorSpacing = typedArray.getDimension(R.styleable.MyTabLayout_indicatorSpacing, dp2px(context, 6f).toFloat()) isTextBold = typedArray.getBoolean(R.styleable.MyTabLayout_isTextBold, true) underlineColor = typedArray.getColor(R.styleable.MyTabLayout_underlineColor, Color.parseColor(&quot;#EEEEEE&quot;)) indicatorColor = typedArray.getColor(R.styleable.MyTabLayout_indicatorColor, Color.BLACK) tabSpaceEqual = typedArray.getBoolean(R.styleable.MyTabLayout_tabSpaceEqual, false) tabPadding = typedArray.getDimension(R.styleable.MyTabLayout_tabPadding, (if (tabSpaceEqual) dp2px(context, 5f) else dp2px(context, 20f)).toFloat()) typedArray.recycle() mRectPaint.color = underlineColor mIndicatorDrawable.setColor(indicatorColor) mTabsContainer = LinearLayout(context) val lp = ViewGroup.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) mTabsContainer!!.layoutParams = lp mTabsContainer!!.gravity = Gravity.CENTER_VERTICAL isFillViewport = true setWillNotDraw(false) isVerticalScrollBarEnabled = false isHorizontalScrollBarEnabled = false addView(mTabsContainer) &#125; //setter and getter fun setCurrentTab(currentTab: Int) &#123; this.mCurrentTab = currentTab mViewPager!!.currentItem = currentTab &#125; fun setCurrentTab(currentTab: Int, smoothScroll: Boolean) &#123; this.mCurrentTab = currentTab mViewPager!!.setCurrentItem(currentTab, smoothScroll) &#125; fun addTab(position: Int, title: String?, textView: TextView?) &#123; if (textView != null) &#123; if (title != null) &#123; textView.gravity = Gravity.CENTER textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textNormalSize) textView.setTextColor(textNormalColor) textView.text = title textView.setOnClickListener &#123; v -&gt; val position = mTabsContainer!!.indexOfChild(v) if (position != -1) &#123; if (mViewPager!!.currentItem != position) &#123; mViewPager!!.currentItem = position &#125; else &#123; if (selectListener != null) &#123; selectListener!!.onTagSelected(position, if (mTitles != null) mTitles!![position] else mViewPager!!.adapter.getPageTitle(position).toString()) &#125; &#125; &#125; &#125; &#125; &#125; val lp = if (tabSpaceEqual) LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.0f) else LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT) lp.gravity = Gravity.CENTER mTabsContainer!!.addView(textView, position, lp) &#125; override fun onDraw(canvas: Canvas) &#123; super.onDraw(canvas) val height = height val paddingLeft = paddingLeft var top = 0 var bottom = height if (mTabsContainer != null &amp;&amp; mTabsContainer!!.getChildAt(mCurrentTab) != null) &#123; top = mTabsContainer!!.getChildAt(mCurrentTab).top bottom = mTabsContainer!!.getChildAt(mCurrentTab).bottom &#125; val tabHeight = top + bottom canvas.drawRect(paddingLeft.toFloat(), height - underlineHeight, (mTabsContainer!!.width + paddingLeft).toFloat(), height.toFloat(), mRectPaint) calcIndicatorRect() if (indicatorHeight &gt; 0 &amp;&amp; indicatorWidth &gt; 0) &#123; mIndicatorDrawable.setBounds(paddingLeft + mIndicatorMarginLeft.toInt() + mIndicatorRect.left, tabHeight - tabPadding.toInt() * 2 + indicatorSpacing.toInt(), paddingLeft + mIndicatorRect.right - mIndicatorMarginRight.toInt(), tabHeight - tabPadding.toInt() * 2 + indicatorSpacing.toInt() + indicatorHeight.toInt()) mIndicatorDrawable.draw(canvas) &#125; else &#123; mIndicatorDrawable.setBounds(paddingLeft + mIndicatorMarginLeft.toInt() + mIndicatorRect.left, height - indicatorHeight.toInt(), paddingLeft + mIndicatorRect.right - mIndicatorMarginRight.toInt(), height) mIndicatorDrawable.draw(canvas) &#125; &#125; private fun calcIndicatorRect() &#123; val currentTabView = mTabsContainer!!.getChildAt(this.mCurrentTab) ?: return var left = currentTabView.left.toFloat() var right = currentTabView.right.toFloat() if (this.mCurrentTab &lt; tabCount - 1) &#123; val nextTabView = mTabsContainer!!.getChildAt(this.mCurrentTab + 1) val nextTabLeft = nextTabView.left.toFloat() val nextTabRight = nextTabView.right.toFloat() left += mCurrentPositionOffset * (nextTabLeft - left) right += mCurrentPositionOffset * (nextTabRight - right) &#125; mIndicatorRect.left = left.toInt() mIndicatorRect.right = right.toInt() mTabRect.left = left.toInt() mTabRect.right = right.toInt() if (indicatorWidth &gt;= 0) &#123; //indicatorWidth大于0时,圆角矩形以及三角形 var indicatorLeft = currentTabView.left + (currentTabView.width - indicatorWidth) / 2 if (this.mCurrentTab &lt; tabCount - 1) &#123; val nextTab = mTabsContainer!!.getChildAt(this.mCurrentTab + 1) indicatorLeft += mCurrentPositionOffset * (currentTabView.width / 2 + nextTab.width / 2) &#125; mIndicatorRect.left = indicatorLeft.toInt() mIndicatorRect.right = (mIndicatorRect.left + indicatorWidth).toInt() &#125; &#125; /** * 关联ViewPager,用于不想在ViewPager适配器中设置titles数据的情况 */ fun setViewPager(vp: ViewPager?, titles: Array&lt;String&gt;) &#123; if (vp == null || vp.adapter == null) &#123; throw IllegalStateException(&quot;ViewPager or ViewPager adapter can not be NULL !&quot;) &#125; if (titles == null || titles.size == 0) &#123; throw IllegalStateException(&quot;Titles can not be EMPTY !&quot;) &#125; if (titles.size != vp.adapter.count) &#123; throw IllegalStateException(&quot;Titles length must be the same as the page count !&quot;) &#125; this.mViewPager = vp mTitles = ArrayList() Collections.addAll(mTitles!!, *titles) this.mViewPager!!.removeOnPageChangeListener(this) this.mViewPager!!.addOnPageChangeListener(this) notifyDataSetChanged() &#125; /** * 关联ViewPager,用于连适配器都不想自己实例化的情况 */ fun setViewPager(vp: ViewPager?, titles: Array&lt;String&gt;?, fa: FragmentActivity, fragments: ArrayList&lt;Fragment&gt;) &#123; if (vp == null) &#123; throw IllegalStateException(&quot;ViewPager can not be NULL !&quot;) &#125; if (titles == null || titles.isEmpty()) &#123; throw IllegalStateException(&quot;Titles can not be EMPTY !&quot;) &#125; this.mViewPager = vp this.mViewPager!!.adapter = InnerPagerAdapter(fa.supportFragmentManager, fragments, titles) this.mViewPager!!.removeOnPageChangeListener(this) this.mViewPager!!.addOnPageChangeListener(this) notifyDataSetChanged() &#125; /** * 更新数据 */ private fun notifyDataSetChanged() &#123; mTabsContainer!!.removeAllViews() this.tabCount = if (mTitles == null) mViewPager!!.adapter.count else mTitles!!.size var tabView: TextView for (i in 0 until tabCount) &#123; tabView = TextView(mContext) val pageTitle = if (mTitles == null) mViewPager!!.adapter.getPageTitle(i) else mTitles!![i] addTab(i, pageTitle.toString(), tabView) &#125; updateTabStyles() &#125; private fun updateTabStyles() &#123; for (i in 0 until tabCount) &#123; val v = mTabsContainer!!.getChildAt(i) val tv_tab_title = v as TextView if (tv_tab_title != null) &#123; tv_tab_title.setTextColor(if (i == mCurrentTab) textSelectColor else textNormalColor) tv_tab_title.setTextSize(TypedValue.COMPLEX_UNIT_PX, if (i == mCurrentTab) textSelectSize else textNormalSize) tv_tab_title.setPadding(tabPadding.toInt(), tabPadding.toInt(), tabPadding.toInt(), tabPadding.toInt()) if (isTextBold) &#123; tv_tab_title.paint.isFakeBoldText = i == mCurrentTab &#125; &#125; &#125; &#125; override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) &#123; this.mCurrentTab = position this.mCurrentPositionOffset = positionOffset scrollToCurrentTab() invalidate() &#125; /** * HorizontalScrollView滚到当前tab,并且居中显示 */ private fun scrollToCurrentTab() &#123; if (tabCount &lt;= 0) &#123; return &#125; val offset = (mCurrentPositionOffset * mTabsContainer!!.getChildAt(mCurrentTab).width).toInt() /**当前Tab的left+当前Tab的Width乘以positionOffset */ var newScrollX = mTabsContainer!!.getChildAt(mCurrentTab).left + offset if (mCurrentTab &gt; 0 || offset &gt; 0) &#123; /**HorizontalScrollView移动到当前tab,并居中 */ newScrollX -= width / 2 - paddingLeft calcIndicatorRect() newScrollX += (mTabRect.right - mTabRect.left) / 2 &#125; if (newScrollX != mLastScrollX) &#123; mLastScrollX = newScrollX /** scrollTo（int x,int y）:x,y代表的不是坐标点,而是偏移量 * x:表示离起始位置的x水平方向的偏移量 * y:表示离起始位置的y垂直方向的偏移量 */ scrollTo(newScrollX, 0) &#125; &#125; override fun onSaveInstanceState(): Parcelable &#123; val bundle = Bundle() bundle.putParcelable(&quot;instanceState&quot;, super.onSaveInstanceState()) bundle.putInt(&quot;mCurrentTab&quot;, mCurrentTab) return bundle &#125; override fun onRestoreInstanceState(state: Parcelable?) &#123; var state = state if (state is Bundle) &#123; val bundle = state as Bundle? mCurrentTab = bundle!!.getInt(&quot;mCurrentTab&quot;) state = bundle.getParcelable(&quot;instanceState&quot;) if (mCurrentTab != 0 &amp;&amp; mTabsContainer!!.childCount &gt; 0) &#123; updateTabSelection(mCurrentTab) scrollToCurrentTab() &#125; &#125; super.onRestoreInstanceState(state) &#125; private fun updateTabSelection(position: Int) &#123; for (i in 0 until tabCount) &#123; val tabView = mTabsContainer!!.getChildAt(i) val isSelect = i == position val tab_title = tabView as TextView if (tab_title != null) &#123; tab_title.setTextColor(if (isSelect) textSelectColor else textNormalColor) tab_title.setTextSize(TypedValue.COMPLEX_UNIT_PX, if (isSelect) textSelectSize else textNormalSize) if (isTextBold) &#123; tab_title.paint.isFakeBoldText = isSelect &#125; &#125; &#125; &#125; override fun onPageSelected(position: Int) = updateTabSelection(position) override fun onPageScrollStateChanged(state: Int) = Unit internal inner class InnerPagerAdapter(fm: FragmentManager, fragments: ArrayList&lt;Fragment&gt;, private val titles: Array&lt;String&gt;) : FragmentPagerAdapter(fm) &#123; private var fragments = ArrayList&lt;Fragment&gt;() init &#123; this.fragments = fragments &#125; override fun getCount(): Int = fragments.size override fun getPageTitle(position: Int): CharSequence = titles[position] override fun getItem(position: Int): Fragment = fragments[position] override fun destroyItem(container: ViewGroup?, position: Int, `object`: Any) =// 覆写destroyItem并且空实现,这样每个Fragment中的视图就不会被销毁 // super.destroyItem(container, position, object); Unit override fun getItemPosition(`object`: Any?): Int = PagerAdapter.POSITION_NONE &#125; interface OnTagSelectListener &#123; fun onTagSelected(position: Int, tag: String) &#125; fun addOnTagSelectListener(listener: OnTagSelectListener) &#123; selectListener = listener &#125; private fun dp2px(context: Context, dp: Float): Int &#123; val scale = context.resources.displayMetrics.density return (dp * scale + 0.5f).toInt() &#125; private fun sp2px(context: Context, sp: Float): Int &#123; val scale = context.resources.displayMetrics.scaledDensity return (sp * scale + 0.5f).toInt() &#125;&#125;","categories":[],"tags":[]},{"title":"MVP模式解析","slug":"Mvp模式解析","date":"2018-01-29T09:59:23.000Z","updated":"2018-01-29T09:59:23.000Z","comments":true,"path":"2018/01/29/Mvp模式解析/","link":"","permalink":"http://yoursite.com/2018/01/29/Mvp模式解析/","excerpt":"","text":"前言： MVP模式是从MVVM 模式转化而来，MVVM是Model-View-ViewModel的简写,而MVP则是Model-View-Presenter 模式，其中Model负责 下面列举两种的差别： 1、MVC MVC 模式是model view 和 controller 三者之间可以互相通信，但是这样就存在一个问题，就是view层可以调用model层和controller层的代码，所以会导致逻辑混乱。 2、MVPMVP 是Model view 和 Presenter 组成，MVP最大的好处就是剥离了Presenter层出来替换掉了Controller，从而使得model 层和view层不能直接进行通信，必须通过presenter层间接进行通信，一般来说一个Activity只有一个presenter层来控制逻辑，但是在复杂的Activity中可以通过绑定多个Presenter来实现复杂的逻辑。 下面为大家展示下我已经封装好的逻辑代码： model : //basemodel 与数据请求相关的接口 public class BaseModel { public interface Classify { void getCookClassify(CallBack callBack); } } //MainModel 实现BaseModel.Classify中的接口进行数据请求 public class MainModel implements BaseModel.Classify { @Override public void getCookClassify(CallBack callBack) { // 数据请求 GetDataList.getCookClassify(callBack); } } view: //baseActivity 源码： public abstract class BaseActivity extends AppCompatActivity { //Presenter 实例 protected T presenter; @Override protected void onCreate(Bundle savedInstanceState) { beforeOnCreate(); super.onCreate(savedInstanceState); setContentView(getLayoutId()); initViews(); initdata(); } protected abstract int getLayoutId(); protected abstract void initViews(); protected abstract void initdata(); protected void beforeOnCreate(){ } @Override protected void onResume() { super.onResume(); afterOnResume(); } protected void afterOnResume(){ } @Override protected void onDestroy() { super.onDestroy(); afterOnDestory(); } protected void afterOnDestory(){ } } //baseview 接口，用来刷新页面数据，可以根据需求添加不同的方法。 public interface BaseView { //显示加载框 void showDialog(); //加载成功 void onSuccess(T t); //加载失败 void onError(Throwable t); //取消加载框 void dismissDialog(); } presenter: public class MainPresenter { // 页面刷新接口 private BaseView baseView; // 数据调用model private BaseModel.Classify cookClassify; public MainPresenter init(BaseView baseView) { this.baseView = baseView; this.cookClassify = new MainModel(); return this; } public void getData() { baseView.showDialog(); cookClassify.getCookClassify(new CallBack() { @Override public void onCompleted() { baseView.dismissDialog(); } @Override public void onError(Throwable e) { baseView.dismissDialog(); baseView.onError(e); } @Override public void onNext(CookClassify cookClassify) { baseView.onSuccess(cookClassify); } }); } } 使用步骤： 在BaseModel 中新建model接口 例：public interface Classify { void getCookClassify(CallBack callBack); } 新建相应的Model实现接口里的方法并进行数据获取 例： public class MainModel implements BaseModel.Classify { @Override public void getCookClassify(CallBack callBack) { GetDataList.getCookClassify(callBack); }} 新建presenter 例： public class MainPresenter { private BaseView baseView; private BaseModel.Classify cookClassify; public MainPresenter init(BaseView baseView) { this.baseView = baseView; this.cookClassify = new MainModel(); return this; } public void getData() { baseView.showDialog(); cookClassify.getCookClassify(new CallBack() { @Override public void onCompleted() { baseView.dismissDialog(); } @Override public void onError(Throwable e) { baseView.dismissDialog(); baseView.onError(e); } @Override public void onNext(CookClassify cookClassify) { baseView.onSuccess(cookClassify); } }); }}继承BaseActivity并传入presenter数据类型 例：public class MainActivity extends BaseActivity&lt;.MainPresenter&gt; implements BaseView { @Overrideprotected void initdata() { // 实例化presenter presenter = new MainPresenter().init(this); presenter.getData(); } @Override public void showDialog() {//todo: 显示dialog } @Override public void onSuccess(CookClassify cookClassify) { //todo: 刷新页面数据 MyListAdapter adapter = getAdapter(); adapter.refreshDatas(cookClassify.getTngou()); } @Override public void onError(Throwable t) { //todo: 错误处理 Log.d(“debug”, “onError===&gt;” + t.getLocalizedMessage()); } @Override public void dismissDialog() { //todo: 取消dialog显示 }} 更多详情见github openobj: github : https://github.com/momentslz 更多内容请添加本人公众号：","categories":[],"tags":[]},{"title":"使用IntentService进行apk更新","slug":"apk更新","date":"2018-01-29T09:20:46.000Z","updated":"2018-01-29T09:59:23.000Z","comments":true,"path":"2018/01/29/apk更新/","link":"","permalink":"http://yoursite.com/2018/01/29/apk更新/","excerpt":"","text":"通常在使用service更新应用时最常出现的问题就是Notification进度的更新问题、service在什么时间关闭以及需要我们自己在Service中创建新的线程处理耗时操作，当然这种也是可以实现的但是会显得略微繁琐经过对比发现可以使用IntentService已经实现了对耗时操作的包装出来，我们只需要实现IntentService中的onHandleIntent方法就可以在其中进行耗时操作的处理，在处理下载问题时发现在使用intentservice时暂时没有发现可以优雅的进行进度回调的实现方法，所以我这边使用了本地广播的形式来进行进度刷新。 添加了当前状态判断，当应用处于前台状态时直接进行安装，当应用处于后台时弹出notification弹窗点击后安装，示例如下图： 先创建广播 1234567891011121314151617181920212223242526272829303132333435public static class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; switch (intent.getAction()) &#123; case ACTION_TYPE_PREPARE: if (downloadCallback != null) &#123; downloadCallback.onPrepare(); &#125; break; case ACTION_TYPE_PROGRESS: int progress = intent.getIntExtra(&quot;progress&quot;, 0);// Log.d(&quot;progress&quot;, &quot;|- &quot; + progress + &quot; -|&quot;); if (downloadCallback != null) &#123; downloadCallback.onProgress(progress); &#125; break; case ACTION_TYPE_COMPLETE: String file_path = intent.getStringExtra(&quot;file_path&quot;); if (!TextUtils.isEmpty(file_path)) &#123; File file = new File(file_path); if (file.exists()) &#123; if (downloadCallback != null) &#123; downloadCallback.onComplete(file); &#125; &#125; &#125; break; case ACTION_TYPE_FAIL: String error = intent.getStringExtra(&quot;error&quot;); if (downloadCallback != null) &#123; downloadCallback.onFail(error + &quot;&quot;); &#125; break; &#125; &#125; 然后在IntentService中初始化本地广播并发送信息 1234567891011121314151617181920@Override public void onCreate() &#123; super.onCreate(); mLocalBroadcastManager = LocalBroadcastManager.getInstance(this); &#125; // 在下载进度刷新的地方进行回调 private void progress(int progress) &#123; Intent intent = new Intent(FileDownloaderManager.ACTION_TYPE_PROGRESS); intent.putExtra(&quot;progress&quot;, progress); mLocalBroadcastManager.sendBroadcast(intent); &#125; private void downApk(String url) &#123; ..... ..... progress(progress); ..... ..... &#125; 在activity中使用 12345678910mLocalBroadcastManager = LocalBroadcastManager.getInstance(mContext);mBroadcastReceiver = new MyBroadcastReceiver();IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(ACTION_TYPE_PREPARE);intentFilter.addAction(ACTION_TYPE_PROGRESS);intentFilter.addAction(ACTION_TYPE_COMPLETE);intentFilter.addAction(ACTION_TYPE_FAIL);mLocalBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);// ondestory时调用mLocalBroadcastManager.unregisterReceiver(mBroadcastReceiver); 以上源码已进行封装，方便使用具体操作步骤如下：|- 初始化及注册回调 123456789101112131415//初始化文件下载管理类FileDownloaderManager.init(context)// 注册下载进度监听，并开启广播接收FileDownloaderManager.registerDownload(object : FileDownloaderManager.DownloadCallback &#123; override fun onComplete(file: File) = mainView.downloadSucc(file) override fun onFail(msg: String?) = Unit override fun onProgress(progress: Int) = mainView.onProgress(progress) override fun onPrepare() = Unit &#125;)//开始下载FileDownloaderManager.download(url) |- 在下载完成后进行资源重置 1FileDownloaderManager.unbinder() 源码地址：源码地址文档地址：文档地址","categories":[],"tags":[{"name":"BroadcastReceiver IntentService","slug":"BroadcastReceiver-IntentService","permalink":"http://yoursite.com/tags/BroadcastReceiver-IntentService/"}]},{"title":"日志记录框架","slug":"Android日志记录框架","date":"2018-01-29T02:20:46.000Z","updated":"2018-01-29T09:59:23.000Z","comments":true,"path":"2018/01/29/Android日志记录框架/","link":"","permalink":"http://yoursite.com/2018/01/29/Android日志记录框架/","excerpt":"","text":"日志记录框架版本 v1.0.0已完成：业务日志、通用日志、错误日志可以正常使用待完善：Action日志当前页面功能、本地存储的上传规则 框架功能简介 使用在需要使用的module的gradle中添加：1compile &apos;com.moment:logconverge:1.0.3-2&apos; 日志框架入口初始化(在Application的onCreate方法中初始化)：在Application中添加代理：12345678910111213141516171819202122232425262728293031323334LogApplicationProxy.getProxy().onCreate(this);LogApplicationProxy.getProxy().onTrimMemory(level);LogApplicationProxy.getProxy().onLowMemory();LogApplicationProxy.getProxy().onTerminate();LogApplicationProxy.getProxy().onConfigurationChanged(newConfig);初始化：LogConverge.Builder builder = new LogConverge .Builder() /** * 设置日志记录级别，日志级别分为(ACTION,EXCEPTION,ALL,NONE) * 通用日志和业务日志默认开启 */ .setLogLevel(LogConverge.ShowLevel.ALL) .setChannel(Constant.channel) /** * 设置日志解析格式 * JSON * Sting */ .setParseType(ParseType.JSON) /** * 设置日志打印方式 * LOGCAT * Toast */ .setPrintType(PrintType.LOGGCAT) /** * 设置日志持久化方式 * 文件 * 数据库 */ .setCacheType(CacheType.DATABASE); //日志框架初始化入口 LogConverge.init(builder, this); Action日志初始化在Fragment(需要日志记录的页面，一般为BaseFragment)中添加代理:123LogProxy.create().onFragmentHiddenChanged(hidden, this.javaClass.simpleName)LogProxy.create().onFragmentResume()LogProxy.create().onFragmentPause() 业务日志使用方法123Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();map.put(&quot;业务名称&quot;, &quot;业务数据&quot;)LogConverge.create().log(map) 框架详情解析业务日志(BusinessLog) 根据业务需求添日志记录.数据结构：Map调用方法：LogConverge.log(Map logs)1234567&#123; &quot;businessLog&quot;: &#123; &quot;name&quot;: &quot;moment&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;age&quot;: 17 &#125;&#125; 通用日志(CommonLog) 框架自动记录，日志字段分别为：设备厂商(devicebrand)系统版本号(sysversion)设备唯一标识(uuid)应用版本(appversion)应用渠道(channel)最大分配内存(memorysize)12345678&#123; &quot;appversion&quot;: &quot;1.0.0&quot;, &quot;channel&quot;: &quot;xiaomi&quot;, &quot;deviceBrand&quot;: &quot;Xiaomi&quot;, &quot;memorysize&quot;: &quot;256M&quot;, &quot;sysversion&quot;: &quot;7.1.1&quot;, &quot;uuid&quot;: &quot;XXXX-XXXX-XXX-XXX-XXXXXXXX&quot;&#125; 错误日志(ExceptionLog) 错误日志分为客户端异常和网络异常客户端异常由框架自动记录网络异常需用户调用方法LogConverge.logNetError(String log)方法实现12345&#123; &quot;error&quot;: &#123; &quot;clientError&quot;: &quot;Attempt to invoke a virtual method on a null object reference case:java.lang.NullPointerException: Attempt to invoke a virtual method on a null object reference&quot; &#125;&#125; ACTION日志(ActionLog)12345678910111213框架自动记录，日志字段分别为：当前页面(currentPage)上一页面(previousPage)进入时间(enterTime)退出时间(exitTime)前一页面停留时间(spendTime)&#123; &quot;currentPage&quot;: &quot;TestActivity&quot;, &quot;enterTime&quot;: 1516076541468, &quot;exitTime&quot;: 1516076630131, &quot;previousPage&quot;: &quot;MainActivity_MainFragment&quot;, &quot;spendTime&quot;: &quot;0h1m28s&quot;&#125; 新加apk下载管理类 示例： |- 在Manifest中进行Service注册 1&lt;service android:name=&quot;com.moment.logconverge.download.DownloadService&quot; /&gt; |- 注册fileProvider 123456789&lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;$&#123;applicationId&#125;.provider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt;&lt;/provider&gt; 在app-src-main-res目录下创建xml文件夹并添加file_paths.xml文件 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;root-path name=&quot;root&quot; path=&quot;&quot; /&gt; &lt;files-path name=&quot;files&quot; path=&quot;&quot; /&gt; &lt;cache-path name=&quot;cache&quot; path=&quot;&quot; /&gt; &lt;external-path name=&quot;external&quot; path=&quot;&quot; /&gt; &lt;external-files-path name=&quot;external_file_path&quot; path=&quot;&quot; /&gt; &lt;external-cache-path name=&quot;external_cache_path&quot; path=&quot;&quot; /&gt;&lt;/paths&gt; |- 初始化及注册进度回调 12345678910111213//初始化文件下载管理类FileDownloaderManager.init(context)// 注册下载进度监听，并开启广播接收FileDownloaderManager.registerDownload(object : FileDownloaderManager.DownloadCallback &#123; override fun onComplete(file: File) = mainView.downloadSucc(file) override fun onFail(msg: String?) = Unit override fun onProgress(progress: Int) = mainView.onProgress(progress) override fun onPrepare() = Unit &#125;) |- 开启下载 1FileDownloaderManager.download(url) |- 在下载完成后进行资源重置 1FileDownloaderManager.unbinder() apk下载混淆添加123-dontwarn okhttp3.**-dontwarn okio.**-dontwarn javax.annotation.** 混淆如下 1234567891011-keep class com.moment.logconverge.entity.**&#123;*;&#125;-dontwarn com.moment.logconverge.entity.**-keep class org.litepal.** &#123; *;&#125;-keep class * extends org.litepal.crud.DataSupport &#123; *;&#125; ThanksJSON解析：fastjson数据库存储：litepal","categories":[],"tags":[{"name":"BroadcastReceiver IntentService","slug":"BroadcastReceiver-IntentService","permalink":"http://yoursite.com/tags/BroadcastReceiver-IntentService/"}]},{"title":"Handler、AsyncTask、HandlerThread和IntentService之间的对比","slug":"Android中处理耗时操作的几种方法","date":"2018-01-29T01:30:46.000Z","updated":"2018-02-23T06:58:00.000Z","comments":true,"path":"2018/01/29/Android中处理耗时操作的几种方法/","link":"","permalink":"http://yoursite.com/2018/01/29/Android中处理耗时操作的几种方法/","excerpt":"","text":"耗时操作的几种操作方式Thread Handler Looper MessageQueue创建handler时会创建looer对象并用looper中的messageQueue对象初始化当前messageQueue当使用handler发送消息时会有两种方式发送：sendMessage和dispatchMessage前者发送的消息会直接发送至messageQueue中通过looper对象循环处理并将结果转发至handler的handleMessage方法中经过了线程之间的切换后者则通过判断是否存在Runnable接口回调来选择返回信息的方式存在的话则直接调用Runnable中的run方法，若不存在则直接调用handler中的handMessage方法，在同一线程完成 在主线程使用在主线程创建handler对象并其修饰为static类型，覆写handleMessage方法对收到的message对象进行处理，从打印信息可以发现当前线程为main线程即主线程，其中的looper对象是在ActivityThread.main中创建的handler 使用示例: 123456789public static Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 10001: Log.d(&quot;main&quot;, msg.obj + &quot;&quot; + Looper.myLooper().getThread().getName()); &#125; &#125; &#125;; thread使用: 123456789new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = handler.obtainMessage(); message.what = 10001; message.obj = &quot;hello&quot;; handler.dispatchMessage(message); &#125; &#125;).start(); 在thread线程中使用handler对象时参考Lopper源码中的示例： 1234567891011121314151617181920212223private class LopperThread extends Thread &#123; private Handler mHandler; @Override public void run() &#123; super.run(); Looper.prepare(); mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 10001: Log.d(&quot;main&quot;, msg.obj + &quot;&quot; + Looper.myLooper().getThread().getName()); &#125; &#125; &#125;; Message message = mHandler.obtainMessage(); message.what = 10001; message.obj = &quot;hello&quot;; mHandler.sendMessage(message); Looper.loop(); &#125; &#125; 使用方法为： 12LopperThread thread = new LopperThread();thread.start(); AsyncTaskasynctask的创建： 12345678910111213141516171819202122232425262728293031public class MyTestTask extends AsyncTask&lt;Integer, Integer, String&gt; &#123; private static final String TAG = MyTestTask.class.getSimpleName(); @Override protected void onPreExecute() &#123; super.onPreExecute(); Log.i(TAG, &quot;onPreExecute-&gt;运行前,主线程)&quot; + Looper.myLooper().getThread().getName()); &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); Log.i(&quot;TAG&quot;, &quot;onPostExecute-&gt;运行后,主线程&quot; + Looper.myLooper().getThread().getName()); &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); Log.i(&quot;TAG&quot;, &quot;onProgressUpdate-&gt;更新进度,主线程&quot; + Looper.myLooper().getThread().getName()); &#125; @Override protected String doInBackground(Integer... params) &#123; Log.i(TAG, &quot;doInBackground-&gt;运行中,子线程&quot;); for (int i = 0; i &lt; 10; i++) &#123; publishProgress(i); &#125; return &quot;finish&quot;; &#125;&#125; 其中三个泛型的参数分别为：Params(传入doInBackground方法中的参数)Progress(onProgressUpdate方法中更新进度的参数)Result(后台执行完成后的返回参数) 使用： 123for (int i = 0; i &lt; 128; i++) &#123; new MyTestTask().execute();&#125; 使用须知：AsyncTask3.0之前为并发执行最大并发数两位128(参见2.3.7源码MAXIMUM_POOL_SIZE = 128)，当并发数量大于128时会报异常3.0之后AsyncTask变为顺序执行，当上一个任务完成后才会执行下一个任务，顺序执行参考链接 HandlerThreadhandlerthread继承自Thread所以本来就是线程，只是在线程的run方法中添加了looper循环来实现耗时操作，在使用时先调用start方法开启线程然后通过mHandlerThread.getLooper()的方法获取handlerThread中的looper对象和新创建的hanlder对象进行绑定即通过以下方法初始化新建的handler： 123public Handler(Looper looper) &#123; this(looper, null, false);&#125; 在handler初始化后即和handlerthread完成绑定，需注意的是耗时操作需在新建的handler的handleMessage方法中进行 12345678910111213@Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; 通过Looper.prepare()和 Looper.loop()实现了looper循环使用方法： 12345678910111213141516初始化：HandlerThread mHandlerThread = new HandlerThread(&quot;myHandlerThread&quot;);mHandlerThread.start();Handler mHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; //耗时操作 do something.... Log.i(&quot;tag&quot;, &quot;message_obj：&quot; + msg.obj.toString()); &#125;&#125;;发送Message：Message msg = new Message();msg.obj = &quot;message_obj&quot;;mHandler.sendMessage(msg); 参考链接 IntentServiceIntentService在onCreate时使用HandlerService对ServiceHandler进行了绑定，在ServiceHandler的handleMessage方法中调用了抽象方法onHandleIntent进行耗时操作，所以在IntentService的onHandleIntent方法中可以进行耗时操作，在onHandleIntent调用后还调用了stopSelf方法结束自己，所以IntentService当执行完耗时操作后会自动销毁 代码示例： 1234567891011121314public class TestIntentService extends IntentService &#123; private static String TAG = &quot;IntentServiceLoad&quot;; public TestIntentService() &#123; super(TAG); &#125; @Override protected void onHandleIntent(Intent intent) &#123; //耗时操作 // TODO: 2018/1/25 do something... Log.d(TAG, &quot;onHandleIntent&quot;); &#125;&#125; 使用方法和service相同就不举例说明了，在应用中一般会用来下载文件","categories":[],"tags":[{"name":"handler LopperThread AsyncTask IntentService","slug":"handler-LopperThread-AsyncTask-IntentService","permalink":"http://yoursite.com/tags/handler-LopperThread-AsyncTask-IntentService/"}]},{"title":"自定义ActionBar","slug":"自定义ActionBar","date":"2016-06-05T01:30:46.000Z","updated":"2018-01-26T03:47:04.000Z","comments":true,"path":"2016/06/05/自定义ActionBar/","link":"","permalink":"http://yoursite.com/2016/06/05/自定义ActionBar/","excerpt":"","text":"前言： 相信大家都用过ActionBar吧，基本上都会去继承AppCompactActivity，但是在某些情况下，想实现一些特殊的效果的时候，系统自带的ActionBar就显得有点儿鸡肋了，不过后面又出了ToolBar控件，大大的弥补了ActionBar的不足，所以本次的自定义ActionBar就是继承的ToolBar，从而实现了ActionBar的高度以及可显示内容的高度定制。 下面列举几种自定义的样式： 1、自定义左侧返回菜单，使用方法见代码： private MyActionBar actionBar; actionBar = (MyActionBar) findViewById(R.id.myactionbar);actionBar.withTitle(“分类目录”) //设置title文字 .setABCallBack(this) // 设置左侧返回按钮，中间自定义菜单及右侧按钮点击事件 .isShowBack(false) //是否显示左侧返回菜单//效果见下图： 2、自定义ActionBar中间的view private MyActionBar actionBar; actionBar = (MyActionBar) findViewById(R.id.myactionbar); //自定义中间的view。 View view = getLayoutInflater().inflate(R.layout.actionbar_center, null); view.findViewById(R.id.btn_click).setOnClickListener(v -> Toast.makeText(getApplicationContext(), \"id:\" + ((Button) v.findViewById(R.id.btn_click)).getText(), Toast.LENGTH_SHORT).show()); actionBar.setABCallBack(this) // 设置左侧返回按钮，中间自定义菜单及右侧按钮点击事件 .isShowBack(false) //是否显示左侧返回菜单 .addCenterView(view); //添加自定义view 见图二TEST按钮 //效果见下图： 3、自定义右侧按钮点击事件 private MyActionBar actionBar; actionBar = (MyActionBar) findViewById(R.id.myactionbar); //右侧item adapter List menuEntities = new ArrayList(); menuEntities.add(new MyPopupWindow.MenuEntity(R.drawable.titlebar_back_press, \"name\")); menuEntities.add(new MyPopupWindow.MenuEntity(R.drawable.titlebar_back_press, \"name1\")); menuEntities.add(new MyPopupWindow.MenuEntity(R.drawable.titlebar_back_press, \"name2\")); actionBar.setABCallBack(this) // 设置左侧返回按钮，中间自定义菜单及右侧按钮点击事件 .isShowBack(false) //是否显示左侧返回菜单 .addMenuList(menuEntities) // 添加右侧按钮item .addCenterView(view); //添加自定义view //效果见下图： MyActionBar 源码： public class MyActionBar extends Toolbar { private int backColor; private int defaultColor; private TextView tvTitle; private ImageView ivBack, ivRight; private RelativeLayout llBackground; private AbCallBack abCallBack; private Context mContext; private LinearLayout llcontainer; private MyPopupWindow popupWindow; public MyActionBar(Context context) { super(context, null); } public MyActionBar(Context context, final AttributeSet attrs) { this(context, attrs, -1); } @TargetApi(Build.VERSION_CODES.M) public MyActionBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); this.mContext = context; defaultColor = context.getColor(R.color.colorPrimary); LayoutInflater.from(context).inflate(R.layout.actionbar, this, true); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyActionBar, 0, 0); backColor = typedArray.getColor(R.styleable.MyActionBar_myactionbar_background, defaultColor); llBackground = (RelativeLayout) findViewById(R.id.ll_background); llBackground.setBackgroundColor(backColor); llcontainer = (LinearLayout) findViewById(R.id.ll_container); tvTitle = (TextView) findViewById(R.id.tv_title); ivBack = (ImageView) findViewById(R.id.iv_back); ivRight = (ImageView) findViewById(R.id.iv_right); ivBack.setColorFilter(getResources().getColor(R.color.white)); ivBack.setOnClickListener(v -> abCallBack.onBackClick()); ivRight.setColorFilter(getResources().getColor(R.color.white)); ivRight.setOnClickListener(v -> popupWindow.show(this)); } public MyActionBar addCenterView(View view) { if (llcontainer != null) { llcontainer.removeAllViews(); llcontainer.addView(view); } return this; } public MyActionBar addCenterViewClickListener(View view) { abCallBack.onCenterViewClick(view); return this; } public MyActionBar setHomeIcon(int resId) { if (mContext != null) { Picasso.with(mContext) .load(resId) .error(R.drawable.titlebar_back_press) .into(ivBack); } return this; } public MyActionBar isShowBack(boolean isShow) { if (!isShow) { ivBack.setVisibility(INVISIBLE); } else { ivBack.setVisibility(VISIBLE); } return this; } public MyActionBar addMenuList(List menuEntityList) { popupWindow = new MyPopupWindow(mContext); popupWindow.addMenuList(menuEntityList) .addOnItemClickLisenter((parent, view, position, id) -> { abCallBack.onRightClick(position); popupWindow.dismiss(); }).build(); return this; } public MyActionBar setABCallBack(AbCallBack abCallBack) { this.abCallBack = abCallBack; return this; } public MyActionBar withTitle(String title) { tvTitle.setText(title); return this; } } AbCallBack （ActionBar点击事件回调）源码： public interface AbCallBack { void onBackClick(); void onRightClick(); } 更多使用方法详见github: github : https://github.com/momentslz/openobj 更多内容请添加本人公众号：","categories":[],"tags":[{"name":"toolbar actionbar","slug":"toolbar-actionbar","permalink":"http://yoursite.com/tags/toolbar-actionbar/"}]}]}