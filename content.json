{"meta":{"title":"刘正的技术博客","subtitle":"胆小认生，不易相处","description":"擅长Android技能,深入研究移动端开发,此为博客一枚。","author":"moment","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"自定义TabLayout","slug":"kotlin眼视频客户端 - 自定义TabLayout","date":"2018-02-24T09:49:39.871Z","updated":"2018-02-24T09:49:39.871Z","comments":true,"path":"2018/02/24/kotlin眼视频客户端 - 自定义TabLayout/","link":"","permalink":"http://yoursite.com/2018/02/24/kotlin眼视频客户端 - 自定义TabLayout/","excerpt":"","text":"本文为kotlin仿开眼视频Android客户端的后续补充内容，本篇为大家介绍如何对TabLayout进行定制使用，基于项目需求，本篇主要对部分功能进行了定制，如：指示器距离文字的距离、文字选中加粗、文字选中变大等 本文部分代码参考：FlycoTabLayout 效果图 效果-1 效果-2 参数详解属性源码 123456789101112131415&lt;declare-styleable name=&quot;MyTabLayout&quot;&gt; &lt;attr name=&quot;textNormalSize&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;textSelectSize&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;textNormalColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;textSelectColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;underLineHeight&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;underlineColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;indicatorHeight&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;indicatorWidth&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;indicatorSpacing&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;isTextBold&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;tabPadding&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;indicatorColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;tabSpaceEqual&quot; format=&quot;boolean&quot; /&gt; &lt;/declare-styleable&gt; 属性参数详解 参数 用处 textNormalSize tab未被选中时字体大小 textSelectSize tab被选中时字体大小 textNormalColor tab未被选中时字体颜色 textSelectColor tab被选中时字体颜色 underLineHeight tablayout下面整个一条的线的高度 underlineColor tablayout下面整个一条的线的颜色 indicatorHeight 文字下方指示器的高度 indicatorWidth 文字下方指示器的宽度 indicatorSpacing 文字下方指示器距离上面文字的间距 indicatorColor 文字下方指示器的颜色 isTextBold 文字选中时是否加粗 tabPadding 文字左右间的间隙大小 tabSpaceEqual tab中的文字是否等分tablayout的宽度，参考效果-2 与viewpager合并使用12345678var mAdapter = MyPagerAdapter(fragmentManager)viewpager.adapter = mAdapter//tab列表val stringArray = mTitle.toArray(arrayOfNulls&lt;String&gt;(0))tab_layout.setViewPager(viewpager, stringArray as Array&lt;String&gt;)viewpager.offscreenPageLimit = 3viewpager.currentItem = 0viewpager.addOnPageChangeListener(this) 源码使用参考详见:https://github.com/momentslz/Eyepetizer源码文件下载地址:https://github.com/momentslz/Eyepetizer/blob/master/app/src/main/java/com/moment/eyepetizer/view/TabLayout.kt 或如代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392/** * Created by moment on 2018/2/22. * FlycoTabLayout 仿写，并提取部分功能原地址链接： * https://github.com/H07000223/FlycoTabLayout */open class TabLayout(context: Context, attrs: AttributeSet) : HorizontalScrollView(context, attrs), ViewPager.OnPageChangeListener &#123; private var mContext: Context? = null private var textNormalSize: Float = 0.toFloat() private var textSelectSize: Float = 0.toFloat() private var textNormalColor: Int = 0 private var textSelectColor: Int = 0 private var underlineHeight: Float = 0.toFloat() private var underlineColor: Int = 0 private var indicatorHeight: Float = 0.toFloat() private var indicatorWidth: Float = 0.toFloat() private var indicatorSpacing: Float = 0.toFloat() private var isTextBold: Boolean = false private var tabPadding: Float = 0.toFloat() private var indicatorColor: Int = 0 private var tabSpaceEqual: Boolean = false private var selectListener: OnTagSelectListener? = null private var mTabsContainer: LinearLayout? = null private var mCurrentTab = 0 private var mViewPager: ViewPager? = null var tabCount: Int = 0 private set private var mTitles: ArrayList&lt;String&gt;? = null private val mRectPaint = Paint(Paint.ANTI_ALIAS_FLAG) private val mIndicatorDrawable = GradientDrawable() /** * indicator */ private val mIndicatorMarginLeft = 0f private val mIndicatorMarginTop = 0f private val mIndicatorMarginRight = 0f /** * 用于绘制显示器 */ private val mIndicatorRect = Rect() private var mCurrentPositionOffset: Float = 0.toFloat() /** * 用于实现滚动居中 */ private val mTabRect = Rect() private var mLastScrollX: Int = 0 init &#123; initResource(context, attrs) &#125; private fun initResource(context: Context, attrs: AttributeSet) &#123; mContext = context val typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyTabLayout) textNormalSize = typedArray.getDimension(R.styleable.MyTabLayout_textNormalSize, sp2px(context, 14f).toFloat()) textSelectSize = typedArray.getDimension(R.styleable.MyTabLayout_textSelectSize, textNormalSize) textNormalColor = typedArray.getColor(R.styleable.MyTabLayout_textNormalColor, Color.GRAY) textSelectColor = typedArray.getColor(R.styleable.MyTabLayout_textSelectColor, Color.BLACK) underlineHeight = typedArray.getDimension(R.styleable.MyTabLayout_underLineHeight, dp2px(context, 0.5f).toFloat()) indicatorWidth = typedArray.getDimension(R.styleable.MyTabLayout_indicatorWidth, -1f) indicatorHeight = typedArray.getDimension(R.styleable.MyTabLayout_indicatorHeight, dp2px(context, 3f).toFloat()) indicatorSpacing = typedArray.getDimension(R.styleable.MyTabLayout_indicatorSpacing, dp2px(context, 6f).toFloat()) isTextBold = typedArray.getBoolean(R.styleable.MyTabLayout_isTextBold, true) underlineColor = typedArray.getColor(R.styleable.MyTabLayout_underlineColor, Color.parseColor(&quot;#EEEEEE&quot;)) indicatorColor = typedArray.getColor(R.styleable.MyTabLayout_indicatorColor, Color.BLACK) tabSpaceEqual = typedArray.getBoolean(R.styleable.MyTabLayout_tabSpaceEqual, false) tabPadding = typedArray.getDimension(R.styleable.MyTabLayout_tabPadding, (if (tabSpaceEqual) dp2px(context, 5f) else dp2px(context, 20f)).toFloat()) typedArray.recycle() mRectPaint.color = underlineColor mIndicatorDrawable.setColor(indicatorColor) mTabsContainer = LinearLayout(context) val lp = ViewGroup.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT) mTabsContainer!!.layoutParams = lp mTabsContainer!!.gravity = Gravity.CENTER_VERTICAL isFillViewport = true setWillNotDraw(false) isVerticalScrollBarEnabled = false isHorizontalScrollBarEnabled = false addView(mTabsContainer) &#125; //setter and getter fun setCurrentTab(currentTab: Int) &#123; this.mCurrentTab = currentTab mViewPager!!.currentItem = currentTab &#125; fun setCurrentTab(currentTab: Int, smoothScroll: Boolean) &#123; this.mCurrentTab = currentTab mViewPager!!.setCurrentItem(currentTab, smoothScroll) &#125; fun addTab(position: Int, title: String?, textView: TextView?) &#123; if (textView != null) &#123; if (title != null) &#123; textView.gravity = Gravity.CENTER textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textNormalSize) textView.setTextColor(textNormalColor) textView.text = title textView.setOnClickListener &#123; v -&gt; val position = mTabsContainer!!.indexOfChild(v) if (position != -1) &#123; if (mViewPager!!.currentItem != position) &#123; mViewPager!!.currentItem = position &#125; else &#123; if (selectListener != null) &#123; selectListener!!.onTagSelected(position, if (mTitles != null) mTitles!![position] else mViewPager!!.adapter.getPageTitle(position).toString()) &#125; &#125; &#125; &#125; &#125; &#125; val lp = if (tabSpaceEqual) LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.0f) else LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT) lp.gravity = Gravity.CENTER mTabsContainer!!.addView(textView, position, lp) &#125; override fun onDraw(canvas: Canvas) &#123; super.onDraw(canvas) val height = height val paddingLeft = paddingLeft var top = 0 var bottom = height if (mTabsContainer != null &amp;&amp; mTabsContainer!!.getChildAt(mCurrentTab) != null) &#123; top = mTabsContainer!!.getChildAt(mCurrentTab).top bottom = mTabsContainer!!.getChildAt(mCurrentTab).bottom &#125; val tabHeight = top + bottom canvas.drawRect(paddingLeft.toFloat(), height - underlineHeight, (mTabsContainer!!.width + paddingLeft).toFloat(), height.toFloat(), mRectPaint) calcIndicatorRect() if (indicatorHeight &gt; 0 &amp;&amp; indicatorWidth &gt; 0) &#123; mIndicatorDrawable.setBounds(paddingLeft + mIndicatorMarginLeft.toInt() + mIndicatorRect.left, tabHeight - tabPadding.toInt() * 2 + indicatorSpacing.toInt(), paddingLeft + mIndicatorRect.right - mIndicatorMarginRight.toInt(), tabHeight - tabPadding.toInt() * 2 + indicatorSpacing.toInt() + indicatorHeight.toInt()) mIndicatorDrawable.draw(canvas) &#125; else &#123; mIndicatorDrawable.setBounds(paddingLeft + mIndicatorMarginLeft.toInt() + mIndicatorRect.left, height - indicatorHeight.toInt(), paddingLeft + mIndicatorRect.right - mIndicatorMarginRight.toInt(), height) mIndicatorDrawable.draw(canvas) &#125; &#125; private fun calcIndicatorRect() &#123; val currentTabView = mTabsContainer!!.getChildAt(this.mCurrentTab) ?: return var left = currentTabView.left.toFloat() var right = currentTabView.right.toFloat() if (this.mCurrentTab &lt; tabCount - 1) &#123; val nextTabView = mTabsContainer!!.getChildAt(this.mCurrentTab + 1) val nextTabLeft = nextTabView.left.toFloat() val nextTabRight = nextTabView.right.toFloat() left += mCurrentPositionOffset * (nextTabLeft - left) right += mCurrentPositionOffset * (nextTabRight - right) &#125; mIndicatorRect.left = left.toInt() mIndicatorRect.right = right.toInt() mTabRect.left = left.toInt() mTabRect.right = right.toInt() if (indicatorWidth &gt;= 0) &#123; //indicatorWidth大于0时,圆角矩形以及三角形 var indicatorLeft = currentTabView.left + (currentTabView.width - indicatorWidth) / 2 if (this.mCurrentTab &lt; tabCount - 1) &#123; val nextTab = mTabsContainer!!.getChildAt(this.mCurrentTab + 1) indicatorLeft += mCurrentPositionOffset * (currentTabView.width / 2 + nextTab.width / 2) &#125; mIndicatorRect.left = indicatorLeft.toInt() mIndicatorRect.right = (mIndicatorRect.left + indicatorWidth).toInt() &#125; &#125; /** * 关联ViewPager,用于不想在ViewPager适配器中设置titles数据的情况 */ fun setViewPager(vp: ViewPager?, titles: Array&lt;String&gt;) &#123; if (vp == null || vp.adapter == null) &#123; throw IllegalStateException(&quot;ViewPager or ViewPager adapter can not be NULL !&quot;) &#125; if (titles == null || titles.size == 0) &#123; throw IllegalStateException(&quot;Titles can not be EMPTY !&quot;) &#125; if (titles.size != vp.adapter.count) &#123; throw IllegalStateException(&quot;Titles length must be the same as the page count !&quot;) &#125; this.mViewPager = vp mTitles = ArrayList() Collections.addAll(mTitles!!, *titles) this.mViewPager!!.removeOnPageChangeListener(this) this.mViewPager!!.addOnPageChangeListener(this) notifyDataSetChanged() &#125; /** * 关联ViewPager,用于连适配器都不想自己实例化的情况 */ fun setViewPager(vp: ViewPager?, titles: Array&lt;String&gt;?, fa: FragmentActivity, fragments: ArrayList&lt;Fragment&gt;) &#123; if (vp == null) &#123; throw IllegalStateException(&quot;ViewPager can not be NULL !&quot;) &#125; if (titles == null || titles.isEmpty()) &#123; throw IllegalStateException(&quot;Titles can not be EMPTY !&quot;) &#125; this.mViewPager = vp this.mViewPager!!.adapter = InnerPagerAdapter(fa.supportFragmentManager, fragments, titles) this.mViewPager!!.removeOnPageChangeListener(this) this.mViewPager!!.addOnPageChangeListener(this) notifyDataSetChanged() &#125; /** * 更新数据 */ private fun notifyDataSetChanged() &#123; mTabsContainer!!.removeAllViews() this.tabCount = if (mTitles == null) mViewPager!!.adapter.count else mTitles!!.size var tabView: TextView for (i in 0 until tabCount) &#123; tabView = TextView(mContext) val pageTitle = if (mTitles == null) mViewPager!!.adapter.getPageTitle(i) else mTitles!![i] addTab(i, pageTitle.toString(), tabView) &#125; updateTabStyles() &#125; private fun updateTabStyles() &#123; for (i in 0 until tabCount) &#123; val v = mTabsContainer!!.getChildAt(i) val tv_tab_title = v as TextView if (tv_tab_title != null) &#123; tv_tab_title.setTextColor(if (i == mCurrentTab) textSelectColor else textNormalColor) tv_tab_title.setTextSize(TypedValue.COMPLEX_UNIT_PX, if (i == mCurrentTab) textSelectSize else textNormalSize) tv_tab_title.setPadding(tabPadding.toInt(), tabPadding.toInt(), tabPadding.toInt(), tabPadding.toInt()) if (isTextBold) &#123; tv_tab_title.paint.isFakeBoldText = i == mCurrentTab &#125; &#125; &#125; &#125; override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) &#123; this.mCurrentTab = position this.mCurrentPositionOffset = positionOffset scrollToCurrentTab() invalidate() &#125; /** * HorizontalScrollView滚到当前tab,并且居中显示 */ private fun scrollToCurrentTab() &#123; if (tabCount &lt;= 0) &#123; return &#125; val offset = (mCurrentPositionOffset * mTabsContainer!!.getChildAt(mCurrentTab).width).toInt() /**当前Tab的left+当前Tab的Width乘以positionOffset */ var newScrollX = mTabsContainer!!.getChildAt(mCurrentTab).left + offset if (mCurrentTab &gt; 0 || offset &gt; 0) &#123; /**HorizontalScrollView移动到当前tab,并居中 */ newScrollX -= width / 2 - paddingLeft calcIndicatorRect() newScrollX += (mTabRect.right - mTabRect.left) / 2 &#125; if (newScrollX != mLastScrollX) &#123; mLastScrollX = newScrollX /** scrollTo（int x,int y）:x,y代表的不是坐标点,而是偏移量 * x:表示离起始位置的x水平方向的偏移量 * y:表示离起始位置的y垂直方向的偏移量 */ scrollTo(newScrollX, 0) &#125; &#125; override fun onSaveInstanceState(): Parcelable &#123; val bundle = Bundle() bundle.putParcelable(&quot;instanceState&quot;, super.onSaveInstanceState()) bundle.putInt(&quot;mCurrentTab&quot;, mCurrentTab) return bundle &#125; override fun onRestoreInstanceState(state: Parcelable?) &#123; var state = state if (state is Bundle) &#123; val bundle = state as Bundle? mCurrentTab = bundle!!.getInt(&quot;mCurrentTab&quot;) state = bundle.getParcelable(&quot;instanceState&quot;) if (mCurrentTab != 0 &amp;&amp; mTabsContainer!!.childCount &gt; 0) &#123; updateTabSelection(mCurrentTab) scrollToCurrentTab() &#125; &#125; super.onRestoreInstanceState(state) &#125; private fun updateTabSelection(position: Int) &#123; for (i in 0 until tabCount) &#123; val tabView = mTabsContainer!!.getChildAt(i) val isSelect = i == position val tab_title = tabView as TextView if (tab_title != null) &#123; tab_title.setTextColor(if (isSelect) textSelectColor else textNormalColor) tab_title.setTextSize(TypedValue.COMPLEX_UNIT_PX, if (isSelect) textSelectSize else textNormalSize) if (isTextBold) &#123; tab_title.paint.isFakeBoldText = isSelect &#125; &#125; &#125; &#125; override fun onPageSelected(position: Int) = updateTabSelection(position) override fun onPageScrollStateChanged(state: Int) = Unit internal inner class InnerPagerAdapter(fm: FragmentManager, fragments: ArrayList&lt;Fragment&gt;, private val titles: Array&lt;String&gt;) : FragmentPagerAdapter(fm) &#123; private var fragments = ArrayList&lt;Fragment&gt;() init &#123; this.fragments = fragments &#125; override fun getCount(): Int = fragments.size override fun getPageTitle(position: Int): CharSequence = titles[position] override fun getItem(position: Int): Fragment = fragments[position] override fun destroyItem(container: ViewGroup?, position: Int, `object`: Any) =// 覆写destroyItem并且空实现,这样每个Fragment中的视图就不会被销毁 // super.destroyItem(container, position, object); Unit override fun getItemPosition(`object`: Any?): Int = PagerAdapter.POSITION_NONE &#125; interface OnTagSelectListener &#123; fun onTagSelected(position: Int, tag: String) &#125; fun addOnTagSelectListener(listener: OnTagSelectListener) &#123; selectListener = listener &#125; private fun dp2px(context: Context, dp: Float): Int &#123; val scale = context.resources.displayMetrics.density return (dp * scale + 0.5f).toInt() &#125; private fun sp2px(context: Context, sp: Float): Int &#123; val scale = context.resources.displayMetrics.scaledDensity return (sp * scale + 0.5f).toInt() &#125;&#125;","categories":[],"tags":[]},{"title":"仿开眼视频Android客户端","slug":"Eyepetizer","date":"2018-02-12T04:35:49.000Z","updated":"2018-02-12T04:35:49.000Z","comments":true,"path":"2018/02/12/Eyepetizer/","link":"","permalink":"http://yoursite.com/2018/02/12/Eyepetizer/","excerpt":"","text":"仿开眼视频Android客户端，本项目主要用来练手Google-MVP已及kotlin,对于急切想熟悉kotlin的童鞋来说是一个不错的练手项目，由于公司任务比较紧急所以本项目目前处于功能完善中，相关技术文章还未整理发布，想参与本项目开发的童鞋可以先自己去熟悉项目并在issues留言，或在目前的基础上进行修改，后续会陆续相关文章会发布到个人主页，欢迎各位积极PR,相关文章发布地址如下： 简书掘金blog源码地址 技术栈googleMvp SlidingTabLayout rxandroid RxRelay RecyclerViewSnap SmartRefreshLayout 1注：技术栈中的相关框架后期会进行源码解析，在原有框架基础上进行功能拓展 首页 关注 搜索 通知 我的 thanks本项目所有API均来自开眼视频，数据接口均属于非正常渠道获取，请勿用于商业用途，原公司拥有数据所有权，侵权删. 链接：开眼视频官网 Demo下载网页下载：下载地址 二维码下载：","categories":[],"tags":[]},{"title":"MVP模式解析","slug":"Mvp模式解析","date":"2018-01-29T09:59:23.000Z","updated":"2018-01-29T09:59:23.000Z","comments":true,"path":"2018/01/29/Mvp模式解析/","link":"","permalink":"http://yoursite.com/2018/01/29/Mvp模式解析/","excerpt":"","text":"前言： MVP模式是从MVVM 模式转化而来，MVVM是Model-View-ViewModel的简写,而MVP则是Model-View-Presenter 模式，其中Model负责 下面列举两种的差别： 1、MVC MVC 模式是model view 和 controller 三者之间可以互相通信，但是这样就存在一个问题，就是view层可以调用model层和controller层的代码，所以会导致逻辑混乱。 2、MVPMVP 是Model view 和 Presenter 组成，MVP最大的好处就是剥离了Presenter层出来替换掉了Controller，从而使得model 层和view层不能直接进行通信，必须通过presenter层间接进行通信，一般来说一个Activity只有一个presenter层来控制逻辑，但是在复杂的Activity中可以通过绑定多个Presenter来实现复杂的逻辑。 下面为大家展示下我已经封装好的逻辑代码： model : //basemodel 与数据请求相关的接口 public class BaseModel { public interface Classify { void getCookClassify(CallBack callBack); } } //MainModel 实现BaseModel.Classify中的接口进行数据请求 public class MainModel implements BaseModel.Classify { @Override public void getCookClassify(CallBack callBack) { // 数据请求 GetDataList.getCookClassify(callBack); } } view: //baseActivity 源码： public abstract class BaseActivity extends AppCompatActivity { //Presenter 实例 protected T presenter; @Override protected void onCreate(Bundle savedInstanceState) { beforeOnCreate(); super.onCreate(savedInstanceState); setContentView(getLayoutId()); initViews(); initdata(); } protected abstract int getLayoutId(); protected abstract void initViews(); protected abstract void initdata(); protected void beforeOnCreate(){ } @Override protected void onResume() { super.onResume(); afterOnResume(); } protected void afterOnResume(){ } @Override protected void onDestroy() { super.onDestroy(); afterOnDestory(); } protected void afterOnDestory(){ } } //baseview 接口，用来刷新页面数据，可以根据需求添加不同的方法。 public interface BaseView { //显示加载框 void showDialog(); //加载成功 void onSuccess(T t); //加载失败 void onError(Throwable t); //取消加载框 void dismissDialog(); } presenter: public class MainPresenter { // 页面刷新接口 private BaseView baseView; // 数据调用model private BaseModel.Classify cookClassify; public MainPresenter init(BaseView baseView) { this.baseView = baseView; this.cookClassify = new MainModel(); return this; } public void getData() { baseView.showDialog(); cookClassify.getCookClassify(new CallBack() { @Override public void onCompleted() { baseView.dismissDialog(); } @Override public void onError(Throwable e) { baseView.dismissDialog(); baseView.onError(e); } @Override public void onNext(CookClassify cookClassify) { baseView.onSuccess(cookClassify); } }); } } 使用步骤： 在BaseModel 中新建model接口 例：public interface Classify { void getCookClassify(CallBack callBack); } 新建相应的Model实现接口里的方法并进行数据获取 例： public class MainModel implements BaseModel.Classify { @Override public void getCookClassify(CallBack callBack) { GetDataList.getCookClassify(callBack); }} 新建presenter 例： public class MainPresenter { private BaseView baseView; private BaseModel.Classify cookClassify; public MainPresenter init(BaseView baseView) { this.baseView = baseView; this.cookClassify = new MainModel(); return this; } public void getData() { baseView.showDialog(); cookClassify.getCookClassify(new CallBack() { @Override public void onCompleted() { baseView.dismissDialog(); } @Override public void onError(Throwable e) { baseView.dismissDialog(); baseView.onError(e); } @Override public void onNext(CookClassify cookClassify) { baseView.onSuccess(cookClassify); } }); }}继承BaseActivity并传入presenter数据类型 例：public class MainActivity extends BaseActivity&lt;.MainPresenter&gt; implements BaseView { @Overrideprotected void initdata() { // 实例化presenter presenter = new MainPresenter().init(this); presenter.getData(); } @Override public void showDialog() {//todo: 显示dialog } @Override public void onSuccess(CookClassify cookClassify) { //todo: 刷新页面数据 MyListAdapter adapter = getAdapter(); adapter.refreshDatas(cookClassify.getTngou()); } @Override public void onError(Throwable t) { //todo: 错误处理 Log.d(“debug”, “onError===&gt;” + t.getLocalizedMessage()); } @Override public void dismissDialog() { //todo: 取消dialog显示 }} 更多详情见github openobj: github : https://github.com/momentslz 更多内容请添加本人公众号：","categories":[],"tags":[]},{"title":"使用IntentService进行apk更新","slug":"apk更新","date":"2018-01-29T09:20:46.000Z","updated":"2018-01-29T09:59:23.000Z","comments":true,"path":"2018/01/29/apk更新/","link":"","permalink":"http://yoursite.com/2018/01/29/apk更新/","excerpt":"","text":"通常在使用service更新应用时最常出现的问题就是Notification进度的更新问题、service在什么时间关闭以及需要我们自己在Service中创建新的线程处理耗时操作，当然这种也是可以实现的但是会显得略微繁琐经过对比发现可以使用IntentService已经实现了对耗时操作的包装出来，我们只需要实现IntentService中的onHandleIntent方法就可以在其中进行耗时操作的处理，在处理下载问题时发现在使用intentservice时暂时没有发现可以优雅的进行进度回调的实现方法，所以我这边使用了本地广播的形式来进行进度刷新。 添加了当前状态判断，当应用处于前台状态时直接进行安装，当应用处于后台时弹出notification弹窗点击后安装，示例如下图： 先创建广播 1234567891011121314151617181920212223242526272829303132333435public static class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; switch (intent.getAction()) &#123; case ACTION_TYPE_PREPARE: if (downloadCallback != null) &#123; downloadCallback.onPrepare(); &#125; break; case ACTION_TYPE_PROGRESS: int progress = intent.getIntExtra(&quot;progress&quot;, 0);// Log.d(&quot;progress&quot;, &quot;|- &quot; + progress + &quot; -|&quot;); if (downloadCallback != null) &#123; downloadCallback.onProgress(progress); &#125; break; case ACTION_TYPE_COMPLETE: String file_path = intent.getStringExtra(&quot;file_path&quot;); if (!TextUtils.isEmpty(file_path)) &#123; File file = new File(file_path); if (file.exists()) &#123; if (downloadCallback != null) &#123; downloadCallback.onComplete(file); &#125; &#125; &#125; break; case ACTION_TYPE_FAIL: String error = intent.getStringExtra(&quot;error&quot;); if (downloadCallback != null) &#123; downloadCallback.onFail(error + &quot;&quot;); &#125; break; &#125; &#125; 然后在IntentService中初始化本地广播并发送信息 1234567891011121314151617181920@Override public void onCreate() &#123; super.onCreate(); mLocalBroadcastManager = LocalBroadcastManager.getInstance(this); &#125; // 在下载进度刷新的地方进行回调 private void progress(int progress) &#123; Intent intent = new Intent(FileDownloaderManager.ACTION_TYPE_PROGRESS); intent.putExtra(&quot;progress&quot;, progress); mLocalBroadcastManager.sendBroadcast(intent); &#125; private void downApk(String url) &#123; ..... ..... progress(progress); ..... ..... &#125; 在activity中使用 12345678910mLocalBroadcastManager = LocalBroadcastManager.getInstance(mContext);mBroadcastReceiver = new MyBroadcastReceiver();IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(ACTION_TYPE_PREPARE);intentFilter.addAction(ACTION_TYPE_PROGRESS);intentFilter.addAction(ACTION_TYPE_COMPLETE);intentFilter.addAction(ACTION_TYPE_FAIL);mLocalBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);// ondestory时调用mLocalBroadcastManager.unregisterReceiver(mBroadcastReceiver); 以上源码已进行封装，方便使用具体操作步骤如下：|- 初始化及注册回调 123456789101112131415//初始化文件下载管理类FileDownloaderManager.init(context)// 注册下载进度监听，并开启广播接收FileDownloaderManager.registerDownload(object : FileDownloaderManager.DownloadCallback &#123; override fun onComplete(file: File) = mainView.downloadSucc(file) override fun onFail(msg: String?) = Unit override fun onProgress(progress: Int) = mainView.onProgress(progress) override fun onPrepare() = Unit &#125;)//开始下载FileDownloaderManager.download(url) |- 在下载完成后进行资源重置 1FileDownloaderManager.unbinder() 源码地址：源码地址文档地址：文档地址","categories":[],"tags":[{"name":"BroadcastReceiver IntentService","slug":"BroadcastReceiver-IntentService","permalink":"http://yoursite.com/tags/BroadcastReceiver-IntentService/"}]},{"title":"日志记录框架","slug":"Android日志记录框架","date":"2018-01-29T02:20:46.000Z","updated":"2018-01-29T09:59:23.000Z","comments":true,"path":"2018/01/29/Android日志记录框架/","link":"","permalink":"http://yoursite.com/2018/01/29/Android日志记录框架/","excerpt":"","text":"日志记录框架版本 v1.0.0已完成：业务日志、通用日志、错误日志可以正常使用待完善：Action日志当前页面功能、本地存储的上传规则 框架功能简介 使用在需要使用的module的gradle中添加：1compile &apos;com.moment:logconverge:1.0.3-2&apos; 日志框架入口初始化(在Application的onCreate方法中初始化)：在Application中添加代理：12345678910111213141516171819202122232425262728293031323334LogApplicationProxy.getProxy().onCreate(this);LogApplicationProxy.getProxy().onTrimMemory(level);LogApplicationProxy.getProxy().onLowMemory();LogApplicationProxy.getProxy().onTerminate();LogApplicationProxy.getProxy().onConfigurationChanged(newConfig);初始化：LogConverge.Builder builder = new LogConverge .Builder() /** * 设置日志记录级别，日志级别分为(ACTION,EXCEPTION,ALL,NONE) * 通用日志和业务日志默认开启 */ .setLogLevel(LogConverge.ShowLevel.ALL) .setChannel(Constant.channel) /** * 设置日志解析格式 * JSON * Sting */ .setParseType(ParseType.JSON) /** * 设置日志打印方式 * LOGCAT * Toast */ .setPrintType(PrintType.LOGGCAT) /** * 设置日志持久化方式 * 文件 * 数据库 */ .setCacheType(CacheType.DATABASE); //日志框架初始化入口 LogConverge.init(builder, this); Action日志初始化在Fragment(需要日志记录的页面，一般为BaseFragment)中添加代理:123LogProxy.create().onFragmentHiddenChanged(hidden, this.javaClass.simpleName)LogProxy.create().onFragmentResume()LogProxy.create().onFragmentPause() 业务日志使用方法123Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();map.put(&quot;业务名称&quot;, &quot;业务数据&quot;)LogConverge.create().log(map) 框架详情解析业务日志(BusinessLog) 根据业务需求添日志记录.数据结构：Map调用方法：LogConverge.log(Map logs)1234567&#123; &quot;businessLog&quot;: &#123; &quot;name&quot;: &quot;moment&quot;, &quot;gender&quot;: &quot;male&quot;, &quot;age&quot;: 17 &#125;&#125; 通用日志(CommonLog) 框架自动记录，日志字段分别为：设备厂商(devicebrand)系统版本号(sysversion)设备唯一标识(uuid)应用版本(appversion)应用渠道(channel)最大分配内存(memorysize)12345678&#123; &quot;appversion&quot;: &quot;1.0.0&quot;, &quot;channel&quot;: &quot;xiaomi&quot;, &quot;deviceBrand&quot;: &quot;Xiaomi&quot;, &quot;memorysize&quot;: &quot;256M&quot;, &quot;sysversion&quot;: &quot;7.1.1&quot;, &quot;uuid&quot;: &quot;XXXX-XXXX-XXX-XXX-XXXXXXXX&quot;&#125; 错误日志(ExceptionLog) 错误日志分为客户端异常和网络异常客户端异常由框架自动记录网络异常需用户调用方法LogConverge.logNetError(String log)方法实现12345&#123; &quot;error&quot;: &#123; &quot;clientError&quot;: &quot;Attempt to invoke a virtual method on a null object reference case:java.lang.NullPointerException: Attempt to invoke a virtual method on a null object reference&quot; &#125;&#125; ACTION日志(ActionLog)12345678910111213框架自动记录，日志字段分别为：当前页面(currentPage)上一页面(previousPage)进入时间(enterTime)退出时间(exitTime)前一页面停留时间(spendTime)&#123; &quot;currentPage&quot;: &quot;TestActivity&quot;, &quot;enterTime&quot;: 1516076541468, &quot;exitTime&quot;: 1516076630131, &quot;previousPage&quot;: &quot;MainActivity_MainFragment&quot;, &quot;spendTime&quot;: &quot;0h1m28s&quot;&#125; 新加apk下载管理类 示例： |- 在Manifest中进行Service注册 1&lt;service android:name=&quot;com.moment.logconverge.download.DownloadService&quot; /&gt; |- 注册fileProvider 123456789&lt;provider android:name=&quot;android.support.v4.content.FileProvider&quot; android:authorities=&quot;$&#123;applicationId&#125;.provider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt;&lt;/provider&gt; 在app-src-main-res目录下创建xml文件夹并添加file_paths.xml文件 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;root-path name=&quot;root&quot; path=&quot;&quot; /&gt; &lt;files-path name=&quot;files&quot; path=&quot;&quot; /&gt; &lt;cache-path name=&quot;cache&quot; path=&quot;&quot; /&gt; &lt;external-path name=&quot;external&quot; path=&quot;&quot; /&gt; &lt;external-files-path name=&quot;external_file_path&quot; path=&quot;&quot; /&gt; &lt;external-cache-path name=&quot;external_cache_path&quot; path=&quot;&quot; /&gt;&lt;/paths&gt; |- 初始化及注册进度回调 12345678910111213//初始化文件下载管理类FileDownloaderManager.init(context)// 注册下载进度监听，并开启广播接收FileDownloaderManager.registerDownload(object : FileDownloaderManager.DownloadCallback &#123; override fun onComplete(file: File) = mainView.downloadSucc(file) override fun onFail(msg: String?) = Unit override fun onProgress(progress: Int) = mainView.onProgress(progress) override fun onPrepare() = Unit &#125;) |- 开启下载 1FileDownloaderManager.download(url) |- 在下载完成后进行资源重置 1FileDownloaderManager.unbinder() apk下载混淆添加123-dontwarn okhttp3.**-dontwarn okio.**-dontwarn javax.annotation.** 混淆如下 1234567891011-keep class com.moment.logconverge.entity.**&#123;*;&#125;-dontwarn com.moment.logconverge.entity.**-keep class org.litepal.** &#123; *;&#125;-keep class * extends org.litepal.crud.DataSupport &#123; *;&#125; ThanksJSON解析：fastjson数据库存储：litepal","categories":[],"tags":[{"name":"BroadcastReceiver IntentService","slug":"BroadcastReceiver-IntentService","permalink":"http://yoursite.com/tags/BroadcastReceiver-IntentService/"}]},{"title":"Handler、AsyncTask、HandlerThread和IntentService之间的对比","slug":"Android中处理耗时操作的几种方法","date":"2018-01-29T01:30:46.000Z","updated":"2018-02-23T06:58:00.684Z","comments":true,"path":"2018/01/29/Android中处理耗时操作的几种方法/","link":"","permalink":"http://yoursite.com/2018/01/29/Android中处理耗时操作的几种方法/","excerpt":"","text":"耗时操作的几种操作方式Thread Handler Looper MessageQueue创建handler时会创建looer对象并用looper中的messageQueue对象初始化当前messageQueue当使用handler发送消息时会有两种方式发送：sendMessage和dispatchMessage前者发送的消息会直接发送至messageQueue中通过looper对象循环处理并将结果转发至handler的handleMessage方法中经过了线程之间的切换后者则通过判断是否存在Runnable接口回调来选择返回信息的方式存在的话则直接调用Runnable中的run方法，若不存在则直接调用handler中的handMessage方法，在同一线程完成 在主线程使用在主线程创建handler对象并其修饰为static类型，覆写handleMessage方法对收到的message对象进行处理，从打印信息可以发现当前线程为main线程即主线程，其中的looper对象是在ActivityThread.main中创建的handler 使用示例: 123456789public static Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 10001: Log.d(&quot;main&quot;, msg.obj + &quot;&quot; + Looper.myLooper().getThread().getName()); &#125; &#125; &#125;; thread使用: 123456789new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = handler.obtainMessage(); message.what = 10001; message.obj = &quot;hello&quot;; handler.dispatchMessage(message); &#125; &#125;).start(); 在thread线程中使用handler对象时参考Lopper源码中的示例： 1234567891011121314151617181920212223private class LopperThread extends Thread &#123; private Handler mHandler; @Override public void run() &#123; super.run(); Looper.prepare(); mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 10001: Log.d(&quot;main&quot;, msg.obj + &quot;&quot; + Looper.myLooper().getThread().getName()); &#125; &#125; &#125;; Message message = mHandler.obtainMessage(); message.what = 10001; message.obj = &quot;hello&quot;; mHandler.sendMessage(message); Looper.loop(); &#125; &#125; 使用方法为： 12LopperThread thread = new LopperThread();thread.start(); AsyncTaskasynctask的创建： 12345678910111213141516171819202122232425262728293031public class MyTestTask extends AsyncTask&lt;Integer, Integer, String&gt; &#123; private static final String TAG = MyTestTask.class.getSimpleName(); @Override protected void onPreExecute() &#123; super.onPreExecute(); Log.i(TAG, &quot;onPreExecute-&gt;运行前,主线程)&quot; + Looper.myLooper().getThread().getName()); &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); Log.i(&quot;TAG&quot;, &quot;onPostExecute-&gt;运行后,主线程&quot; + Looper.myLooper().getThread().getName()); &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); Log.i(&quot;TAG&quot;, &quot;onProgressUpdate-&gt;更新进度,主线程&quot; + Looper.myLooper().getThread().getName()); &#125; @Override protected String doInBackground(Integer... params) &#123; Log.i(TAG, &quot;doInBackground-&gt;运行中,子线程&quot;); for (int i = 0; i &lt; 10; i++) &#123; publishProgress(i); &#125; return &quot;finish&quot;; &#125;&#125; 其中三个泛型的参数分别为：Params(传入doInBackground方法中的参数)Progress(onProgressUpdate方法中更新进度的参数)Result(后台执行完成后的返回参数) 使用： 123for (int i = 0; i &lt; 128; i++) &#123; new MyTestTask().execute();&#125; 使用须知：AsyncTask3.0之前为并发执行最大并发数两位128(参见2.3.7源码MAXIMUM_POOL_SIZE = 128)，当并发数量大于128时会报异常3.0之后AsyncTask变为顺序执行，当上一个任务完成后才会执行下一个任务，顺序执行参考链接 HandlerThreadhandlerthread继承自Thread所以本来就是线程，只是在线程的run方法中添加了looper循环来实现耗时操作，在使用时先调用start方法开启线程然后通过mHandlerThread.getLooper()的方法获取handlerThread中的looper对象和新创建的hanlder对象进行绑定即通过以下方法初始化新建的handler： 123public Handler(Looper looper) &#123; this(looper, null, false);&#125; 在handler初始化后即和handlerthread完成绑定，需注意的是耗时操作需在新建的handler的handleMessage方法中进行 12345678910111213@Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; 通过Looper.prepare()和 Looper.loop()实现了looper循环使用方法： 12345678910111213141516初始化：HandlerThread mHandlerThread = new HandlerThread(&quot;myHandlerThread&quot;);mHandlerThread.start();Handler mHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; //耗时操作 do something.... Log.i(&quot;tag&quot;, &quot;message_obj：&quot; + msg.obj.toString()); &#125;&#125;;发送Message：Message msg = new Message();msg.obj = &quot;message_obj&quot;;mHandler.sendMessage(msg); 参考链接 IntentServiceIntentService在onCreate时使用HandlerService对ServiceHandler进行了绑定，在ServiceHandler的handleMessage方法中调用了抽象方法onHandleIntent进行耗时操作，所以在IntentService的onHandleIntent方法中可以进行耗时操作，在onHandleIntent调用后还调用了stopSelf方法结束自己，所以IntentService当执行完耗时操作后会自动销毁 代码示例： 1234567891011121314public class TestIntentService extends IntentService &#123; private static String TAG = &quot;IntentServiceLoad&quot;; public TestIntentService() &#123; super(TAG); &#125; @Override protected void onHandleIntent(Intent intent) &#123; //耗时操作 // TODO: 2018/1/25 do something... Log.d(TAG, &quot;onHandleIntent&quot;); &#125;&#125; 使用方法和service相同就不举例说明了，在应用中一般会用来下载文件","categories":[],"tags":[{"name":"handler LopperThread AsyncTask IntentService","slug":"handler-LopperThread-AsyncTask-IntentService","permalink":"http://yoursite.com/tags/handler-LopperThread-AsyncTask-IntentService/"}]},{"title":"自定义ActionBar","slug":"自定义ActionBar","date":"2016-06-05T01:30:46.000Z","updated":"2018-01-26T03:47:04.000Z","comments":true,"path":"2016/06/05/自定义ActionBar/","link":"","permalink":"http://yoursite.com/2016/06/05/自定义ActionBar/","excerpt":"","text":"前言： 相信大家都用过ActionBar吧，基本上都会去继承AppCompactActivity，但是在某些情况下，想实现一些特殊的效果的时候，系统自带的ActionBar就显得有点儿鸡肋了，不过后面又出了ToolBar控件，大大的弥补了ActionBar的不足，所以本次的自定义ActionBar就是继承的ToolBar，从而实现了ActionBar的高度以及可显示内容的高度定制。 下面列举几种自定义的样式： 1、自定义左侧返回菜单，使用方法见代码： private MyActionBar actionBar; actionBar = (MyActionBar) findViewById(R.id.myactionbar);actionBar.withTitle(“分类目录”) //设置title文字 .setABCallBack(this) // 设置左侧返回按钮，中间自定义菜单及右侧按钮点击事件 .isShowBack(false) //是否显示左侧返回菜单//效果见下图： 2、自定义ActionBar中间的view private MyActionBar actionBar; actionBar = (MyActionBar) findViewById(R.id.myactionbar); //自定义中间的view。 View view = getLayoutInflater().inflate(R.layout.actionbar_center, null); view.findViewById(R.id.btn_click).setOnClickListener(v -> Toast.makeText(getApplicationContext(), \"id:\" + ((Button) v.findViewById(R.id.btn_click)).getText(), Toast.LENGTH_SHORT).show()); actionBar.setABCallBack(this) // 设置左侧返回按钮，中间自定义菜单及右侧按钮点击事件 .isShowBack(false) //是否显示左侧返回菜单 .addCenterView(view); //添加自定义view 见图二TEST按钮 //效果见下图： 3、自定义右侧按钮点击事件 private MyActionBar actionBar; actionBar = (MyActionBar) findViewById(R.id.myactionbar); //右侧item adapter List menuEntities = new ArrayList(); menuEntities.add(new MyPopupWindow.MenuEntity(R.drawable.titlebar_back_press, \"name\")); menuEntities.add(new MyPopupWindow.MenuEntity(R.drawable.titlebar_back_press, \"name1\")); menuEntities.add(new MyPopupWindow.MenuEntity(R.drawable.titlebar_back_press, \"name2\")); actionBar.setABCallBack(this) // 设置左侧返回按钮，中间自定义菜单及右侧按钮点击事件 .isShowBack(false) //是否显示左侧返回菜单 .addMenuList(menuEntities) // 添加右侧按钮item .addCenterView(view); //添加自定义view //效果见下图： MyActionBar 源码： public class MyActionBar extends Toolbar { private int backColor; private int defaultColor; private TextView tvTitle; private ImageView ivBack, ivRight; private RelativeLayout llBackground; private AbCallBack abCallBack; private Context mContext; private LinearLayout llcontainer; private MyPopupWindow popupWindow; public MyActionBar(Context context) { super(context, null); } public MyActionBar(Context context, final AttributeSet attrs) { this(context, attrs, -1); } @TargetApi(Build.VERSION_CODES.M) public MyActionBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); this.mContext = context; defaultColor = context.getColor(R.color.colorPrimary); LayoutInflater.from(context).inflate(R.layout.actionbar, this, true); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyActionBar, 0, 0); backColor = typedArray.getColor(R.styleable.MyActionBar_myactionbar_background, defaultColor); llBackground = (RelativeLayout) findViewById(R.id.ll_background); llBackground.setBackgroundColor(backColor); llcontainer = (LinearLayout) findViewById(R.id.ll_container); tvTitle = (TextView) findViewById(R.id.tv_title); ivBack = (ImageView) findViewById(R.id.iv_back); ivRight = (ImageView) findViewById(R.id.iv_right); ivBack.setColorFilter(getResources().getColor(R.color.white)); ivBack.setOnClickListener(v -> abCallBack.onBackClick()); ivRight.setColorFilter(getResources().getColor(R.color.white)); ivRight.setOnClickListener(v -> popupWindow.show(this)); } public MyActionBar addCenterView(View view) { if (llcontainer != null) { llcontainer.removeAllViews(); llcontainer.addView(view); } return this; } public MyActionBar addCenterViewClickListener(View view) { abCallBack.onCenterViewClick(view); return this; } public MyActionBar setHomeIcon(int resId) { if (mContext != null) { Picasso.with(mContext) .load(resId) .error(R.drawable.titlebar_back_press) .into(ivBack); } return this; } public MyActionBar isShowBack(boolean isShow) { if (!isShow) { ivBack.setVisibility(INVISIBLE); } else { ivBack.setVisibility(VISIBLE); } return this; } public MyActionBar addMenuList(List menuEntityList) { popupWindow = new MyPopupWindow(mContext); popupWindow.addMenuList(menuEntityList) .addOnItemClickLisenter((parent, view, position, id) -> { abCallBack.onRightClick(position); popupWindow.dismiss(); }).build(); return this; } public MyActionBar setABCallBack(AbCallBack abCallBack) { this.abCallBack = abCallBack; return this; } public MyActionBar withTitle(String title) { tvTitle.setText(title); return this; } } AbCallBack （ActionBar点击事件回调）源码： public interface AbCallBack { void onBackClick(); void onRightClick(); } 更多使用方法详见github: github : https://github.com/momentslz/openobj 更多内容请添加本人公众号：","categories":[],"tags":[{"name":"toolbar actionbar","slug":"toolbar-actionbar","permalink":"http://yoursite.com/tags/toolbar-actionbar/"}]}]}