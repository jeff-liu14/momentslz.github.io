{"meta":{"title":"刘正的技术博客","subtitle":"胆小认生，不易相处","description":"擅长Android技能,深入研究移动端开发,此为博客一枚。","author":"moment","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-01-26T04:13:37.802Z","updated":"2018-01-26T04:13:37.802Z","comments":true,"path":"2018/01/26/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"MVP模式解析","slug":"Mvp模式解析","date":"2018-01-26T03:47:04.000Z","updated":"2018-01-26T03:47:04.000Z","comments":true,"path":"2018/01/26/Mvp模式解析/","link":"","permalink":"http://yoursite.com/2018/01/26/Mvp模式解析/","excerpt":"","text":"前言： MVP模式是从MVVM 模式转化而来，MVVM是Model-View-ViewModel的简写,而MVP则是Model-View-Presenter 模式，其中Model负责 下面列举两种的差别： 1、MVC MVC 模式是model view 和 controller 三者之间可以互相通信，但是这样就存在一个问题，就是view层可以调用model层和controller层的代码，所以会导致逻辑混乱。 2、MVPMVP 是Model view 和 Presenter 组成，MVP最大的好处就是剥离了Presenter层出来替换掉了Controller，从而使得model 层和view层不能直接进行通信，必须通过presenter层间接进行通信，一般来说一个Activity只有一个presenter层来控制逻辑，但是在复杂的Activity中可以通过绑定多个Presenter来实现复杂的逻辑。 下面为大家展示下我已经封装好的逻辑代码： model : //basemodel 与数据请求相关的接口 public class BaseModel { public interface Classify { void getCookClassify(CallBack callBack); } } //MainModel 实现BaseModel.Classify中的接口进行数据请求 public class MainModel implements BaseModel.Classify { @Override public void getCookClassify(CallBack callBack) { // 数据请求 GetDataList.getCookClassify(callBack); } } view: //baseActivity 源码： public abstract class BaseActivity extends AppCompatActivity { //Presenter 实例 protected T presenter; @Override protected void onCreate(Bundle savedInstanceState) { beforeOnCreate(); super.onCreate(savedInstanceState); setContentView(getLayoutId()); initViews(); initdata(); } protected abstract int getLayoutId(); protected abstract void initViews(); protected abstract void initdata(); protected void beforeOnCreate(){ } @Override protected void onResume() { super.onResume(); afterOnResume(); } protected void afterOnResume(){ } @Override protected void onDestroy() { super.onDestroy(); afterOnDestory(); } protected void afterOnDestory(){ } } //baseview 接口，用来刷新页面数据，可以根据需求添加不同的方法。 public interface BaseView { //显示加载框 void showDialog(); //加载成功 void onSuccess(T t); //加载失败 void onError(Throwable t); //取消加载框 void dismissDialog(); } presenter: public class MainPresenter { // 页面刷新接口 private BaseView baseView; // 数据调用model private BaseModel.Classify cookClassify; public MainPresenter init(BaseView baseView) { this.baseView = baseView; this.cookClassify = new MainModel(); return this; } public void getData() { baseView.showDialog(); cookClassify.getCookClassify(new CallBack() { @Override public void onCompleted() { baseView.dismissDialog(); } @Override public void onError(Throwable e) { baseView.dismissDialog(); baseView.onError(e); } @Override public void onNext(CookClassify cookClassify) { baseView.onSuccess(cookClassify); } }); } } 使用步骤： 在BaseModel 中新建model接口 例：public interface Classify { void getCookClassify(CallBack callBack); } 新建相应的Model实现接口里的方法并进行数据获取 例： public class MainModel implements BaseModel.Classify { @Override public void getCookClassify(CallBack callBack) { GetDataList.getCookClassify(callBack); }} 新建presenter 例： public class MainPresenter { private BaseView baseView; private BaseModel.Classify cookClassify; public MainPresenter init(BaseView baseView) { this.baseView = baseView; this.cookClassify = new MainModel(); return this; } public void getData() { baseView.showDialog(); cookClassify.getCookClassify(new CallBack() { @Override public void onCompleted() { baseView.dismissDialog(); } @Override public void onError(Throwable e) { baseView.dismissDialog(); baseView.onError(e); } @Override public void onNext(CookClassify cookClassify) { baseView.onSuccess(cookClassify); } }); }}继承BaseActivity并传入presenter数据类型 例：public class MainActivity extends BaseActivity&lt;.MainPresenter&gt; implements BaseView { @Overrideprotected void initdata() { // 实例化presenter presenter = new MainPresenter().init(this); presenter.getData(); } @Override public void showDialog() {//todo: 显示dialog } @Override public void onSuccess(CookClassify cookClassify) { //todo: 刷新页面数据 MyListAdapter adapter = getAdapter(); adapter.refreshDatas(cookClassify.getTngou()); } @Override public void onError(Throwable t) { //todo: 错误处理 Log.d(“debug”, “onError===&gt;” + t.getLocalizedMessage()); } @Override public void dismissDialog() { //todo: 取消dialog显示 }} 更多详情见github openobj: github : https://github.com/momentslz 更多内容请添加本人公众号：","categories":[],"tags":[]},{"title":"openobj技术选型","slug":"openobj技术选型","date":"2018-01-26T03:47:04.000Z","updated":"2018-01-26T03:47:04.000Z","comments":true,"path":"2018/01/26/openobj技术选型/","link":"","permalink":"http://yoursite.com/2018/01/26/openobj技术选型/","excerpt":"","text":"网络框架：Retrofit 之所以会选择上面的组合模式呢，想必大家也知道square良心出品，功能方面我就不用说了，可谓是功能齐全，主要还是看中了其优雅的代码风格，想必大家都听过RxJava但是真正的去使用的很少吧，其实并没有想象中的难，主要是很少有公司愿意去使用，学习成本会让公司望而生畏。 接下来的时间我会用自己的开源项目openobj来作为长期更新的项目来为大家讲解使用工程中遇到的一些问题。及才过的坑。 图片加载框架：Picasso 其实之前一直在纠结是用哪种图片框架好呢，之前用过Imageloader、Fresco等多种图片框架。 imageloader 不用说老牌的图片加载框架，功能齐全唯一用下来的问题就是个人觉得使用方法还是太复杂繁琐 Fresco，facebook出品，功能没得说，异常的强大几乎覆盖了你所能想到的所有关于图片加载的功能，至于遇见的坑就不在这里细说了，我只能说可定制性太差。 项目预览： 本人微信公众号： 项目已上传至github 有兴趣的朋友可以先去下载使用。有什么想要实现的或者想要加的新功能都可以给我提issue哦。git地址：https://github.com/momentslz后续将持续更新开发中遇到我的问题及解决方法，欢迎关注哦~","categories":[],"tags":[]},{"title":"Android中处理耗时操作的几种方法","slug":"Android中处理耗时操作的几种方法","date":"2018-01-26T01:30:46.000Z","updated":"2018-01-26T06:02:13.815Z","comments":true,"path":"2018/01/26/Android中处理耗时操作的几种方法/","link":"","permalink":"http://yoursite.com/2018/01/26/Android中处理耗时操作的几种方法/","excerpt":"","text":"耗时操作的几种操作方式Thread Handler Looper MessageQueue创建handler时会创建looer对象并用looper中的messageQueue对象初始化当前messageQueue当使用handler发送消息时会有两种方式发送：sendMessage和dispatchMessage前者发送的消息会直接发送至messageQueue中通过looper对象循环处理并将结果转发至handler的handleMessage方法中经过了线程之间的切换后者则通过判断是否存在Runnable接口回调来选择返回信息的方式存在的话则直接调用Runnable中的run方法，若不存在则直接调用handler中的handMessage方法，在同一线程完成 在主线程使用在主线程创建handler对象并其修饰为static类型，覆写handleMessage方法对收到的message对象进行处理，从打印信息可以发现当前线程为main线程即主线程，其中的looper对象是在ActivityThread.main中创建的handler 使用示例: 123456789public static Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 10001: Log.d(&quot;main&quot;, msg.obj + &quot;&quot; + Looper.myLooper().getThread().getName()); &#125; &#125; &#125;; thread使用: 123456789new Thread(new Runnable() &#123; @Override public void run() &#123; Message message = handler.obtainMessage(); message.what = 10001; message.obj = &quot;hello&quot;; handler.dispatchMessage(message); &#125; &#125;).start(); 在thread线程中使用handler对象时参考Lopper源码中的示例： 1234567891011121314151617181920212223private class LopperThread extends Thread &#123; private Handler mHandler; @Override public void run() &#123; super.run(); Looper.prepare(); mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 10001: Log.d(&quot;main&quot;, msg.obj + &quot;&quot; + Looper.myLooper().getThread().getName()); &#125; &#125; &#125;; Message message = mHandler.obtainMessage(); message.what = 10001; message.obj = &quot;hello&quot;; mHandler.sendMessage(message); Looper.loop(); &#125; &#125; 使用方法为： 12LopperThread thread = new LopperThread();thread.start(); AsyncTaskasynctask的创建： 12345678910111213141516171819202122232425262728293031public class MyTestTask extends AsyncTask&lt;Integer, Integer, String&gt; &#123; private static final String TAG = MyTestTask.class.getSimpleName(); @Override protected void onPreExecute() &#123; super.onPreExecute(); Log.i(TAG, &quot;onPreExecute-&gt;运行前,主线程)&quot; + Looper.myLooper().getThread().getName()); &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); Log.i(&quot;TAG&quot;, &quot;onPostExecute-&gt;运行后,主线程&quot; + Looper.myLooper().getThread().getName()); &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); Log.i(&quot;TAG&quot;, &quot;onProgressUpdate-&gt;更新进度,主线程&quot; + Looper.myLooper().getThread().getName()); &#125; @Override protected String doInBackground(Integer... params) &#123; Log.i(TAG, &quot;doInBackground-&gt;运行中,子线程&quot;); for (int i = 0; i &lt; 10; i++) &#123; publishProgress(i); &#125; return &quot;finish&quot;; &#125;&#125; 其中三个泛型的参数分别为：Params(传入doInBackground方法中的参数)Progress(onProgressUpdate方法中更新进度的参数)Result(后台执行完成后的返回参数) 使用： 123for (int i = 0; i &lt; 128; i++) &#123; new MyTestTask().execute();&#125; 使用须知：AsyncTask3.0之前为并发执行最大并发数两位128(参见2.3.7源码MAXIMUM_POOL_SIZE = 128)，当并发数量大于128时会报异常3.0之后AsyncTask变为顺序执行，当上一个任务完成后才会执行下一个任务，顺序执行参考链接 HandlerThreadhandlerthread继承自Thread所以本来就是线程，只是在线程的run方法中添加了looper循环来实现耗时操作，在使用时先调用start方法开启线程然后通过mHandlerThread.getLooper()的方法获取handlerThread中的looper对象和新创建的hanlder对象进行绑定即通过以下方法初始化新建的handler： 123public Handler(Looper looper) &#123; this(looper, null, false);&#125; 在handler初始化后即和handlerthread完成绑定，需注意的是耗时操作需在新建的handler的handleMessage方法中进行 12345678910111213@Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; 通过Looper.prepare()和 Looper.loop()实现了looper循环使用方法： 12345678910111213141516初始化：HandlerThread mHandlerThread = new HandlerThread(&quot;myHandlerThread&quot;);mHandlerThread.start();Handler mHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; //耗时操作 do something.... Log.i(&quot;tag&quot;, &quot;message_obj：&quot; + msg.obj.toString()); &#125;&#125;;发送Message：Message msg = new Message();msg.obj = &quot;message_obj&quot;;mHandler.sendMessage(msg); 参考链接 IntentServiceIntentService在onCreate时使用HandlerService对ServiceHandler进行了绑定，在ServiceHandler的handleMessage方法中调用了抽象方法onHandleIntent进行耗时操作，所以在IntentService的onHandleIntent方法中可以进行耗时操作，在onHandleIntent调用后还调用了stopSelf方法结束自己，所以IntentService当执行完耗时操作后会自动销毁 代码示例： 1234567891011121314public class TestIntentService extends IntentService &#123; private static String TAG = &quot;IntentServiceLoad&quot;; public TestIntentService() &#123; super(TAG); &#125; @Override protected void onHandleIntent(Intent intent) &#123; //耗时操作 // TODO: 2018/1/25 do something... Log.d(TAG, &quot;onHandleIntent&quot;); &#125;&#125; 使用方法和service相同就不举例说明了，在应用中一般会用来下载文件","categories":[],"tags":[{"name":"toolbar actionbar","slug":"toolbar-actionbar","permalink":"http://yoursite.com/tags/toolbar-actionbar/"}]},{"title":"自定义ActionBar","slug":"自定义ActionBar","date":"2016-06-05T01:30:46.000Z","updated":"2018-01-26T03:47:04.000Z","comments":true,"path":"2016/06/05/自定义ActionBar/","link":"","permalink":"http://yoursite.com/2016/06/05/自定义ActionBar/","excerpt":"","text":"前言： 相信大家都用过ActionBar吧，基本上都会去继承AppCompactActivity，但是在某些情况下，想实现一些特殊的效果的时候，系统自带的ActionBar就显得有点儿鸡肋了，不过后面又出了ToolBar控件，大大的弥补了ActionBar的不足，所以本次的自定义ActionBar就是继承的ToolBar，从而实现了ActionBar的高度以及可显示内容的高度定制。 下面列举几种自定义的样式： 1、自定义左侧返回菜单，使用方法见代码： private MyActionBar actionBar; actionBar = (MyActionBar) findViewById(R.id.myactionbar);actionBar.withTitle(“分类目录”) //设置title文字 .setABCallBack(this) // 设置左侧返回按钮，中间自定义菜单及右侧按钮点击事件 .isShowBack(false) //是否显示左侧返回菜单//效果见下图： 2、自定义ActionBar中间的view private MyActionBar actionBar; actionBar = (MyActionBar) findViewById(R.id.myactionbar); //自定义中间的view。 View view = getLayoutInflater().inflate(R.layout.actionbar_center, null); view.findViewById(R.id.btn_click).setOnClickListener(v -> Toast.makeText(getApplicationContext(), \"id:\" + ((Button) v.findViewById(R.id.btn_click)).getText(), Toast.LENGTH_SHORT).show()); actionBar.setABCallBack(this) // 设置左侧返回按钮，中间自定义菜单及右侧按钮点击事件 .isShowBack(false) //是否显示左侧返回菜单 .addCenterView(view); //添加自定义view 见图二TEST按钮 //效果见下图： 3、自定义右侧按钮点击事件 private MyActionBar actionBar; actionBar = (MyActionBar) findViewById(R.id.myactionbar); //右侧item adapter List menuEntities = new ArrayList(); menuEntities.add(new MyPopupWindow.MenuEntity(R.drawable.titlebar_back_press, \"name\")); menuEntities.add(new MyPopupWindow.MenuEntity(R.drawable.titlebar_back_press, \"name1\")); menuEntities.add(new MyPopupWindow.MenuEntity(R.drawable.titlebar_back_press, \"name2\")); actionBar.setABCallBack(this) // 设置左侧返回按钮，中间自定义菜单及右侧按钮点击事件 .isShowBack(false) //是否显示左侧返回菜单 .addMenuList(menuEntities) // 添加右侧按钮item .addCenterView(view); //添加自定义view //效果见下图： MyActionBar 源码： public class MyActionBar extends Toolbar { private int backColor; private int defaultColor; private TextView tvTitle; private ImageView ivBack, ivRight; private RelativeLayout llBackground; private AbCallBack abCallBack; private Context mContext; private LinearLayout llcontainer; private MyPopupWindow popupWindow; public MyActionBar(Context context) { super(context, null); } public MyActionBar(Context context, final AttributeSet attrs) { this(context, attrs, -1); } @TargetApi(Build.VERSION_CODES.M) public MyActionBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); this.mContext = context; defaultColor = context.getColor(R.color.colorPrimary); LayoutInflater.from(context).inflate(R.layout.actionbar, this, true); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.MyActionBar, 0, 0); backColor = typedArray.getColor(R.styleable.MyActionBar_myactionbar_background, defaultColor); llBackground = (RelativeLayout) findViewById(R.id.ll_background); llBackground.setBackgroundColor(backColor); llcontainer = (LinearLayout) findViewById(R.id.ll_container); tvTitle = (TextView) findViewById(R.id.tv_title); ivBack = (ImageView) findViewById(R.id.iv_back); ivRight = (ImageView) findViewById(R.id.iv_right); ivBack.setColorFilter(getResources().getColor(R.color.white)); ivBack.setOnClickListener(v -> abCallBack.onBackClick()); ivRight.setColorFilter(getResources().getColor(R.color.white)); ivRight.setOnClickListener(v -> popupWindow.show(this)); } public MyActionBar addCenterView(View view) { if (llcontainer != null) { llcontainer.removeAllViews(); llcontainer.addView(view); } return this; } public MyActionBar addCenterViewClickListener(View view) { abCallBack.onCenterViewClick(view); return this; } public MyActionBar setHomeIcon(int resId) { if (mContext != null) { Picasso.with(mContext) .load(resId) .error(R.drawable.titlebar_back_press) .into(ivBack); } return this; } public MyActionBar isShowBack(boolean isShow) { if (!isShow) { ivBack.setVisibility(INVISIBLE); } else { ivBack.setVisibility(VISIBLE); } return this; } public MyActionBar addMenuList(List menuEntityList) { popupWindow = new MyPopupWindow(mContext); popupWindow.addMenuList(menuEntityList) .addOnItemClickLisenter((parent, view, position, id) -> { abCallBack.onRightClick(position); popupWindow.dismiss(); }).build(); return this; } public MyActionBar setABCallBack(AbCallBack abCallBack) { this.abCallBack = abCallBack; return this; } public MyActionBar withTitle(String title) { tvTitle.setText(title); return this; } } AbCallBack （ActionBar点击事件回调）源码： public interface AbCallBack { void onBackClick(); void onRightClick(); } 更多使用方法详见github: github : https://github.com/momentslz/openobj 更多内容请添加本人公众号：","categories":[],"tags":[{"name":"toolbar actionbar","slug":"toolbar-actionbar","permalink":"http://yoursite.com/tags/toolbar-actionbar/"}]}]}